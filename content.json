{"pages":[],"posts":[{"title":"HTML5新特性","text":"HTML5 是下⼀代 HTML 标准。HTML , HTML 4.01的上⼀个版本诞⽣于 1999 年。⾃从那以后，Web 世界已经经历了巨变。HTML5 是 W3C 与 WHATWG 合作的结果,WHATWG 指 WebHypertext Application Technology Working Group。HTML5 是专⻔为承载丰富的 web 内容⽽设计的，并且⽆需额外插件。HTML5 拥有新的语义、图形以及多媒体元素。HTML5 提供的新元素和新的 API 简化了 web 应⽤程序的搭建。HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、⼿机、电视机等等）之上运⾏ 新增标签 语义化根据结构化的内容选择合适的标签，&lt;header&gt;，&lt;footer&gt;，&lt;nav&gt;，… 有利于SEO 开发维护体验好 ⽤户体验更好 更好的可访问性，⽅便任何设备对代码进⾏解析 Microdata 与 schema.org 结合搜索引擎，⽹络抓取⼯具和浏览器可以从⽹⻚中提取和处理微数据，并使⽤它为⽤户提供更丰富的浏览体验。⾕歌和其他主要搜索引擎⽀持结构化数据的Schema.org词汇表。⾕歌，微软和雅⻁等主要搜索引擎运营商依靠schema.org 词汇表来改进搜索结果。 增强表单 新增input输入类型，改善更好的输入控制和验证，如 color，date，email，number，tel等 新增表单属性：placehoder，required，pattern，autofocus，autocomplete，min，max等 媒体html5提供了音频和视频文件的标准 音频 12345&lt;audio controls&gt; //controls属性提供添加播放、暂停和音量控件。 &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;您的浏览器不支持 audio 元素。 //浏览器不支持时显示文字&lt;/audio&gt; 视频 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;您的浏览器不支持Video标签。&lt;/video&gt; 图形HTML5提供了原生绘图功能，完全整合于HTML5 documents (DOM的⼀部分)，由CSS提供样式，由 JavaScript来绘制 canvas绘图MDN Canvas文档 SVG 什么是SVG SVG指可伸缩矢量图形 SVG用于定义用于网络的基于矢量的图形 SVG使用XML格式定义图形 SVG图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG是万维网联盟的标准 SVG的优势 SVG图像可通过文本编译器来创建和修改 SVG图像可被搜索、索引、脚本化或压缩 SVG是可伸缩的 SVG图像可在任何的分辨率下被高质量的打印 SVG可在图像质量不下降的情况下被放大 SVG与canvas对比 SVG SVG 是⼀种使⽤ XML 描述 2D 图形的语⾔ SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可⽤的，您可以为某个元素附加 JavaScript 事件处理器 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发⽣变化，那么浏览器能够⾃动重现图形 canvas Canvas 通过 JavaScript 来绘制 2D 图形 Canvas 是逐像素进⾏渲染的 在 canvas 中，⼀旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发⽣变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 存储HTML5 web存储是⼀个⽐cookie更好的本地存储⽅式。 客户端存储数据的两个对象为： localStorage - ⽤于⻓久保存整个⽹站的数据，保存的数据没有过期时间，直到⼿动去除。 sessionStorage - ⽤于临时保存同⼀窗⼝(或标签⻚)的数据，在关闭窗⼝或标签⻚之后将会删除这些数据。 其他API 地理位置 HTML5 Geolocation API ⽤于获得⽤户的地理位置 拖放 在html5中，拖放是标准的一部分，任何元素都能够拖放 1&lt;div draggable=&quot;true&quot;&gt;&lt;/div&gt; 当元素拖动时，我们可以检查其拖动的数据 123456&lt;div draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot;&gt;&lt;/div&gt;&lt;script&gt;function drap(ev){ console.log(ev);}&lt;/script&gt;","link":"/2021/10/12/HTML5/"},{"title":"商务智能复习","text":"概要 前继课程 数据库系统原理 关系数据模型 连接 数据库构建的步骤和方法（概念到逻辑 逻辑到物理） 后继课程 数据挖掘 评分 作业30%-40% 考试60%-70% 商务智能的起源 数据库系统的发展 最主要：关系模型 数据层级和业务逻辑的解耦 一份数据可以为多个应用使用 以关系型数据库为基础 数据存放代价越来越低 导致业务系统和信息系统越来越复杂，累积了大量数据（数据库不值钱辣 数据库越来越多，数据会变得越来越定制化 其他倾向（使得数据越来越多）: 计算平台的发展 计算、存储、网络/非网络（物理介质）传输能力 ==采集手段的发展== 基于光学——二维码、图像、视频 传感器、移动设备 RFID（物联网） 👇 ==数据爆炸== 数据、信息、知识 知识值链：数据 数据的意义或信息是由附加在这个数据上的其它内容来说明的，数据本身并不知情 exp： 5000是什么？ price：5000才可以说明问题 在应用开发的阶段，不需要让用户知道数据的意义，只有DBA和对当前数据库做增删改查的业务系统的开发人需要知道这层意义（当然很多情况下他们就是一类人） 知识值链：信息 一系列有关联的数据组合，互相进行解释，使得它们的歧义变得相对更少，得到信息 知识值链：知识 信息中的数据，为什么是这个值，不是其它的值 企业的新问题 企业决策需要 全面了解企业和行业的真实状况 真实状况来自于真实完整的数据 有效将收集的数据转化为信息并最终为企业决策所使用 零售业的EXP： 在复杂零售集团中，有两套业务系统，分别对于统一的和专有的内容进行管理，比如各个部门有自己的系统，但是集团人员的管理是统一的 但是部门太多，每个部门有自己的information workers，每个部门都是摸象的盲人，企业决策者是听取所有摸了象的盲人的报告的盲人，怎么决策？（不能信任任何一个信息工人 要把企业的所有相关情况按照全局方式进行展现👇 数据爆炸、信息贫乏的情况下，要解决信息的： 可访问性 及时性 表达格式 完整性 早期解决方案 第一代：基于主机的查询与报表 只能把少部分信息按照规定的格式推送给决策者 这些报表是有限的数据片段（构不成完整信息体）的有限的信息，过于琐碎，也不完整 第二代：数据仓库 把有限的数据片段聚合，以信息体作为存放单元 仓库中的数据默认统一、一致、完整、”正确“ 为何需要商务智能 如何访问数据仓库？如何利用信息体？ 用机器来做决策？ 商务智能 商务： Buying and selling; commerce; trade 智能（约等于人工智能）：（不适用于商务）（没有规则、没有评估标准） 人工智能：图灵测试、专家系统（典型：人工医疗系统，把西医的专业知识写成概率数据） 目标： 并非解决商务领域的人工智能 改善信息访问 现状：数据分散，而数据仓库中的数据过于完整繁杂 需要精确而概要的数据 仍旧是以人来进行主导： 精力限制 知识背景限制，数据是用来验证猜测的，但知识背景会限制猜测，所以更高级的目标是决策支持 决策支持 只是提供一种支持，比如发现的规律，并非做决策 自动化、半自动化产生输入，决策仍由人来做 比如面包和牛奶高度相关是一个自动化产生的输入，但超市到底应该怎么摆这两样东西，还是由人来决策（而且决策可能完成不一样） 概念：BI是将数据转换为有意义的内容的过程 BI通过把来自于不同系统的数据汇聚成一个单一的可获取的信息源并放入数据仓库（Data Warehouse） 然后基于用户的要求，使用各种工具来分析数据仓库中的数据，并可视化结果，再交给用户做决策 BI系统的功能 不仅支持最新的IT技术，同时也提供打包的应用解决方案（针对企业的立足领域） 前者是日常操作的解决方案，比较固定，可能定期调用，需要的东西不会产生太大的变化 战术性决策支持——影响程度小、执行周期固定 但有些决策是随时间会发生很大的变化的，需要的数据可能也不一样，这就是后者的作用 战略性决策支持——没有套路、提供工具随用随构建 商务智能的构件商务智能的发展商务智能的构件1. BI的构件 传统数据存储：数据库、文件、主页（main frame）、专业相关业务系统、个人计算机（本地） 存的是数据片段（大象的碎片嘿） 结构由每一个业务系统在开发时要解决的问题决定，而非决策人员或BI系统 大噶都是数据源，广义上来说也在BI系统中，狭义上说这块东西本质不可控，BI系统不含数据源 数据仓库 存放信息体 关系模型、多维数据库 也可以拿出一部分作为数据集市，方便管理、提高效率 从1 ==&gt; 2有一个转换（数据到信息的转换） 数据整合ETL 把数据片段整合成信息体 组合得到的信息不一定是正确的，但认为是完整、统一、正确的 相关分析 可视化、脚本…… 提供战略性决策支持 ===&gt; 狭义认为商务智能系统包括：数据仓库和对其中数据进行分析的工具 2. 数据仓库part integrative data 是冗余的数据 当由操作需要比较大的数据量，并且这个操作不会只进行一次，为了提高效率，需要integrative data 数据库是做不到的 3. 数据获取（从1-2的转换需要） 建模工具 不同地方的数据片段可能会对同一样东西进行不同的编码 映射到数据仓库需要建模工具 元数据 ETL 是元数据和建模工具的编码结果 4. 数据与信息 源数据、转换过程——数据 数据仓库——数据&amp;信息 分析工具——信息 5. 数据源 包含内容 操作型数据库 历史数据 包括： 如果是已经用不到的历史数据，会被放到廉价的非在线的存储设备中 当有重要的历史数据需要被查询时，还是可以找到的 也有本操作型/事务型数据库创建之前的历史数据 外部数据（“外部”由企业边界所决定） 没有太大必要性（有必要的话就在操作型数据库中了） 可能是其它企业的数据、中央政策啥的 对于事务性任务来说并不需要，但对于决策分析来说是有必要的，所以也是BI系统的数据源 数据仓库中的信息 一种理解：对数据仓库中的信息进行了分析之后得出的结论又作为数据源放入数据仓库的各个信息体中，使得它们更完整 另一种理解：理论上来说一个企业应该只有一个数据仓库（数据一致性的问题），而外部数据很有可能是一个外部仓库 相关的数据库和数据结构 ===&gt; 数据源存在于不同平台，可以是格式化的，也可以是非格式化的 6. 数据仓库 是BI的重要组成部分和数据基础 工作： ETL： 数据抽取、转换、装载 辨识和主题相关的原始数据 并不是所有采集到的数据都适合作为信息体的一部分（毕竟我的目的是由企业目标决定的，而不是要搞出一个完整的信息体来） 去除分析型环境下无用的数据（高度主观） 数据是否有用和主管分析、上下文、企业关注点有关 开发正确的数据抽取策略 抽取正确和完整的数据 正确的话，比如理解数据源中的编码方式 要达到完整，数据结构要完整，数据源一定要完整，时间上也要完整 将原始数据转换为目标规格 是多到多的映射关系 数据源多个 数据仓库中会有冗余（可能经过了操作 integrative data） 将原始数据加载到预定目标区域 数据目标 数据管理 存储、索引、备份 不仅管理关系数据库中的数据 而且管理数据立方体中的多维数据 数据访问 面向多种商业用户 需要支持多种访问方式以及分析和展现工具 元数据 关于数据的数据，是管理数据仓库的重要数据 描述数据的结构、内容、编码、索引等 种类 关于数据源的元数据 需要正确解析数据源中的数据 关于数据模型的元数据 关于数据仓库映射的元数据 映射成局部的数据、数据集市、数据的概要等 关于数据仓库使用的元数据 比如数据仓库中已经存了一些中间结果可以直接用 元数据管理 7. 分析和展现层 报表和查询 定制报表和查询的能力 OLAP（联机分析处理） 快速的、交互式的相互融合的信息访问方式 可以回答who、what、how、why类的问题 数据库是单维的（列才有意义） 特点 对数据进行多维审视的能力 相关数据已经被整合到一起了 ===&gt; 信息 精密计算能力 时间智能 基本操作 数据统计 将数据中含有的信息概括为统计值 数据挖掘 对数据库（数据仓库）中蕴涵的、未知的、非平凡的、有潜在应用价值的模式（规则）的提取 蕴涵的：非显式的，但数据会对”挖掘“出的决策产生支持 未知的：只针对当前数据集或以后和该数据集有相同规则的其它数据集 非平凡的：无法判定结果的100%对或100%错 不同的数据方法、同一种数据方法不同的参数、同一种数据方法同一个参数运行多次 都有可能得出不同结论 用于发掘数据中隐藏的模式 可以自动化、可以人工 数据上升到信息 商务智能的解决方案商务智能的发展数据仓库从数据库到数据仓库 数据处理分类 操作型处理（增删改查、“随机”发生） 事务处理 对数据库的日常联机访问操作 通常仅仅对一个或一组记录的查询和修改 AKA：联机事务处理（OLTP） 查询简单，执行频率高 关心的是处理的响应时间、数据的安全性和完整性等 分析型处理 AKA：信息型处理 拿到的东西是既成事实，无法修改 主要用于企业管理人员的决策分析，提供辅助决策信息 主观性强，大部分操作事先是未知的 需要对大量事务型数据进行统计、归纳和分析 需要访问大量的历史数据、内外部数据 执行频率不高，对响应时间的要求不高 所面向数据的分类 操作型数据 事务处理所需要的细节性的数据 分析型数据 从操作型数据中加工整理得到 是分析处理所需要的综合性数据 多维的 是只读的 信息系统的发展历史 事务处理系统（TPS）对数据库进行增删改查 管理信息系统（MIS）基于数据库产生的统计报表 统计报表仅基于当前数据库 不可定制 对一些影响比较小的决策起一些作用 主管信息系统（EIS） 跨若干数据库，做全局意义上的决策 需要外部数据 决策支持系统（DSS） 增加了算法 OLAP / DM 基于数据仓库 决策支持系统 数据（数据库、方法库） 算法与模型 展示 事务处理环境和分析处理 在关系数据库中放宽对冗余的限制 数据库以前不允许冗余，因为会有数据一致性问题（all or nothing） 但问题是，所有分析型数据都是操作型数据的冗余嘿 在事务处理环境下建立传统DSS——不适宜 性能特性不同 事务处理 &lt;—&gt; 分析处理 要同时实现可能会非常麻烦（而且不一定能实现 数据集成的问题 DSS需要集成的数据，可能来自多种不同的数据源 事务处理只需要部分细节数据，是分散的 “蜘蛛网”问题 — 每个数据库的数据来源可能错综复杂（互相抄属性值） 数据不一致问题 分散的概念： 对于数据来说，一个信息体的数据项是分散的 对于信息体来说，信息体本身也是分散的 带来的问题 性能很差，可能集成时需要等待很慢的数据库 数据的动态集成问题 人工方式只能做一次集成 — 静态集成 — 难以实现“周期性刷新”（动态集成） — 传统事务处理环境无法实现 历史数据问题 分析处理更看重历史数据，而事务处理一般只需要当前数据 事务处理环境（数据库）下历史数据未能得到充分利用，会被放在别的地方 历史一致性 / 完整性 当前数据库只保有当前最新状态，并不会体现状态的更新和修改过程（因为并不在乎历史数据），比如limit从2500更新到5000，最后拿到历史数据的时候，limit就是5000，不会存在2500 修改主键 or 增加表 使用连接 数据的综合问题 分析处理需要大量的总结性分析型数据 数据库：“数据丰富、信息贫困” 传统事务处理系统不具备综合能力，甚至这种综合还会被认为时一种数据冗余而被限制 数据的访问问题 分析处理的访问以读为主，不需要实时“更新”，但需要周期“刷新” 综上：出现了数据仓库 并非替代数据库 两者目的不同 ​ 数据仓库及其四大特征 定义 是一个面向主题的、集成的、稳定（非易失）的、随时间不断变化的数据集合 用于支持经营管理过程中的决策制定 面向主题（与数据库区别最大的特征） 数据库：面向应用 与数据流程高度相关 逻辑数据不完全分离 和部门、组织紧密相关 信息体不完全 数据仓库：面向主题 抽象 按照某种方式把原来的数据按定义的上下文整合成信息体中的某一个领域 可能不是完整的信息体，但是有意义的 主观有需求，客观有数据 不同主题有重叠内容，但这种重叠的特点是： 逻辑上的而非物理存储上的 部分细节重叠 可以反映不同主题之间直接和间接的关系 每个主题所需数据的物理存储 多维数据库 多维数组 关系数据库 用二维数据模型来存放多维数据 集成 方法： 统一：消除不同数据源之间数据不一致的现象 综合：综合计算 非易失的（稳定的） 数据仓库的数据与操作性数据环境隔离 但数据仓库中的数据也是需要“更新”的 时变的（随时间不断变化） 数据仓库中的数据带有时间属性，包括历史记录和现在的数据都在 以一定时间段为单位进行统一更新 数据仓库的基本结构数据集市于数据仓库数据仓库的应用数据仓库的基本结构数据仓库的关键技术 ETL过程 把来自各种数据源（异构）的数据整合统一后形成一个面向主题的信息体放入数据结构中 数据 ==&gt; 信息 流程： 数据源是异构的：文件、字节流、网页、桌面数据库文件系统等 要从数据源中抽取数据： 必须理解原先数据源中的数据结构、编码等 也要能够理解某一个数据源中的数据与其它数据源中的数据的关系，比如有无重叠、含义是否相同等 解析、校正： 在数据库中，进入数据库前就有各种方法来确保数据正确，那么为什么数据仓库还要校正？ 数据库的数据的校验不能认作靠谱 增补（根据数据项的重要性来选择方法）: 缺失的数据项：大部分的元组都有这个数据项，小部分没有（如果都没有，说明这个数据项就不该存在） 如果有该数据项的元组足够多，那就把那些数据项缺失的元组排除在分析之外 但可能会造成倾斜的数据结果 最坏情况下，完整记录数量会非常少（每个数据项可能都有元组缺失） 以特定标准给元组分类 对于每个类别，以数据项已知的元组来猜测数据项未知的元组 例如： 以每年在某处的平均消费分类，2万以下、2-5万、5万以上 第三类中家庭收入已知的元组大部分家庭年收入在50万以上 合理猜测这一类中家庭收入未知的元组的家庭年收入也在50万以上 匹配： 此时数据结构已经相同，要将属于同一个信息体的数据片段匹配后合并 数据源 可以是递归的 数据的抽取与刷新 刷新的过程是抽取部分的增量 抽取： 是数据进入仓库的入口 屏蔽了底层数据的结构复杂性和物理位置的复杂性 转换和集成的复杂性 操作型环境到数据仓库环境的数据抽取要实现技术上的变化 尽量避免从在线窗口进行数据抽取 在线窗口的数据可能非持久性数据 在线窗口的数据进入数据库时可能已经做过调整，使用更方便 来自操作型环境中的输入关键字在输出到数据仓库之前需要被重建和转换 非关键字要更新格式 存在多个输入记录时，进行记录合并之前要先进行关键字解析（属于同一个信息体的学号、身份证号等要对应起来才能合并） 产生多个输出结果：并发 原来顺序：多个输入 — 1个信息体 — 多个输出（分析数据） 1个信息体可能是瓶颈 ETL工具 数据目标（有效的数据存放位置） 原子层和集成数据 因为计算资源有限，提前算出一些经常使用的数据 ==&gt; 集成数据 数据集市 某个部门或个人分析应用主题用到的数据的子集 提升在特定领域的分析应用效果 操作数据存储ODS 某些部门或个人战术性决策需要实时或准实时的数据 无法在数据仓库中得到直接支持（数据仓库至少以24小时为周期刷新） 在数据仓库以外，持有与数据仓库相同的结构，也是面向主题的 ODS刷新周期较短，刷新频次远高于当前数据仓库 数据仓库面向全局，包含的主题可能有上千个，刷新成本较高，计算瓶颈在数据库 ODS面向明确的、局部的主题，数据量远小于数据仓库 ODS也可以成为数据仓库的数据源（数据结构一样吼） 缓冲区 数据刷新 在原先数据库中确定哪些元组需要更新 确定方式 时间戳：然而问题是大多数数据库中的数据不含有时间属性 DELTA文件： 不信任数据库，应用对数据库进行增删改查时，自己去记录做的操作 效率比较高，不需要对整个数据库对比扫描 但这样的应用很少，理应是数据库完成的任务 日志文件 由数据库自己生成 建立映像文件 做快照（copy） 数据周期（在数据仓库中）：不低于24小时 数据量不以数据周期定义 有些数据库里的数据可能会被撤销，不需要进入数据仓库 刷新会占用软硬件资源和网络传输资源 数据颠簸性 个人理解：数据库中的数据在固定的一段时间内修改得会比较多，这段时间后数据就基本稳定下来了（这个时间一般为24小时） 数据仓库中的数据以及数据管理 数据： 包括细节性业务数据和分析型数据 管理： 借助数据库技术 具体： 原子层（核心、基础）：最详细、数据量最大、存放最多细节 其它数据结构借助原子层来计算分析数据，目的是加速 特点： 保持历史完整性（即记录有意义的历史数据，意义来自主管需求） 构建是迭代的（非一蹴而就） 数据结构是迭代的 随主观 &amp; 客观变化而修改 即使在数据仓库相对稳定的运作过程中，数据内容也在迭代 数据结构面向企业 可以是集成（非原始数据）的 原本最详细是指与数据源中的数据粒度保持一致 若存储资源不足，并且也没有相应需求，则原子层中就存集成数据（在数据源基础上集成 是静态的 一次ETL完毕到下一次ETL开始，原子层是一个静态的镜像，访问多次都是一样的 即一段时间内是静态的 数据库非静态 粒度 对数据仓库中数据的综合程度的一个度量 影响数据仓库中数据量 影响数据仓库能够回答询问的种类 样本数据库（抽样）： 数据仓库的子集，数据量更小 不能用于一般性的分析目的，只能用于统计分析 粒度可以根据采样率高低来划分 多重粒度 分析应用中主流的查询要求是比较综合的，但也会有很小一部分的查询是很细节的 这个细节查询也需要满足 真实数据仓库中：多重粒度 原子层中按最细粒度给出完整数据 从原子层中计算、聚合数据得到高粒度数据以满足综合查询 不同粒度用不同设备存储 多维度、多层次：数据仓库中 维度是观察数据对象的角度 层次是数据对象的综合程度 一个维度中，例如时间维度可以有天、周、月等 每一个对应维度都可以泳有多个层次 数据仓库的数据组织形式 简单堆积文件 轮转综合文件 针对综合层次 在简单堆积之上继续操作 第一层一次写满之后进行聚合放到第二层 第二层和第三层也是一样 简化直接文件 数据集市与数据仓库1. 建立数据集市的原因 数据仓库是全局的，数据量很大，对于一个部门来说，不需要这么多数据就已经可以做出决策了 数据集市（部门数据仓库）是反映子主题的数据仓库的真子集，与部门的分析领域相关 ==数据结构可以和数据仓库不一样== 然鹅理论上来讲是和数据仓库严格对应的，在ETL时就会被写进去 ===&gt; 提高效率与性能 ===&gt; 提高数据安全性（权限控制） 操作型数据库 vs. 数据集市 业务与分析的区别 没有对应关系 数据集市的数据不一定是来源于本部门 联机分析处理OLAP1. OLAP 从OLTP到OLAP OLTP：联机事务处理 OLAP：联机分析处理 OLAP： 专门的数据综合引擎（OLTP【细节】中没有） 公共应用逻辑：数据散布在不同数据源，针对这些数据进行整合的业务逻辑 在短时间内响应非数据处理专业人员的复杂查询要求 要求在线 ===&gt; 短时间 &amp; 在线是无法在OLTP中实现的 针对特定问题的联机数据访问和分析 对信息的很多种可能的观察形式（多维度多层次）进行存取 OLAP vs. OLTP 2. OLAP的特征及衡量标准 Codd关于OLAP的评价准则 OLAP必须提供多维概念试图 信息体是多维的，上下文不止一个 透明性准则 OLAP在体系结构中的位置对用户是透明的 服务器在哪、计算在哪、数据结构如何等都是对用户透明 OLAP的数据源对用户透明 存取能力准则 底层异质数据存储进行多维展现 OLAP存取应该用统一的相同的界面 稳定的报表功能 数据的维数和综合层次增加时，提供报表能力和响应速度不能有明显的减慢 C/S体系结构 现在不一定了，可以是P2P 维的同等性原则 当前信息体在所有维度上能完成的操作应该是一样的 例如普通三维 + 第四维时间，在x轴上可以向后平移，但在时间轴上不可，就不满足同等性 动态的稀疏矩阵处理准则 为什么会存在稀疏问题？ 同等数据量下维度的增加（维度的增加造成可能的取值空间增大） 多用户支持能力准则 并发访问 分时 问题： OLAP往往不止由数据仓库（不要求在线）支撑，还会有其它的支撑 非受限的跨维操作 比如年月日这种固有的层次关系 直观的数据操作 灵活的报表生成 不受限维度和聚集层次 度量值 分析型处理中，关系和分析的对象 数据是衡量的标准 维 观察度量值的角度 度量值关联到其它数据构成维度 层 反映对度量值的观察深度 粒度 按日、周、月、年，都是不同层次 划分方式 OLAP天然支持 指定 细粒度数据不一定能算出高粒度数据 如周数据可能算不出月数据（周可能跨月） 可以主观指定 时间维、地域维、商品维 层次数量和基数成反比 维成员 维的一个取值 可以是层次，也可以是层次组合 多维数组 维度(n) + 度量值(k)、 为每一个维度指定一个维成员（一个集合）来拿取当前度量值 度量值不会被拿出来直接解释 要给定当前维中的维成员 数据单元（单元格） 存放多维数据确定的度量值 多维数组和联机分析处理 可能性很多，需要提升访问性能 3. OLAP的几个基本概念4. OLAP中的数据构造方式 ROLAP（关系数据库管理系统） 把多维数组用关系型数据库管理 多维查询首先要翻译成数据库语言（SQL），期待得到一个结果集 MOLAP 多维数据库管理系统，基本数据模型就是多维数组 下标访问 多维数据引擎直接访问 ===&gt; 更快 HOLAP（混合） 上两种各有利弊 适合放在R的放R，适合放M的放M 反复应用综合数据放在多维数据库（作为加速机制）中 减小数据量 类比缓存（调度、命中） OLAP需要解决的问题 提高数据访问效率 ETL &amp; 查询 &amp; 更新效率 5. OLAP的基本数据模型 更关注OLAP数据访问的效率 数据存放 结合MOLAP和ROLAP MOLAP MDDB vs. RDBMS MDDB： Data File适合放稠密数据，效率会很高（算偏移，直接查 高层次数据会更稠密 高层次数据增加维度有低层次数据支撑 给某个维度插入维成员麻烦（时间复杂度高） 无论数据有无定义，在多维数据模型中都有这个数据的位置 RDBMS： 二维，有定义才会存在于二维表中 两类数据分成两个表存 存放有定义的度量值的事实表 维度使得作为数据的度量值上升为信息 度量值若为向量，则他包含若干列 维度用外关键字来加以涵盖 存放维属性及其取值的维度表 查询： 以维度表作为入口做二维查询 查询得到每一个维度的结果集 把得到的所有结果集进行自然连接后查询事实表 得到事实表的子集（度量值），进行聚合 ===&gt; 效率低于MDDB，但解决了稀疏矩阵的问题 增加维成员不影响原数据结构 增加维度会导致维度表和事实表属性（外关键字）的增加 ===&gt; 应对变化更灵活 星型模型 多维表结构 事实表 x 1 维表 x n 可以转化为一系列二维表 （纸质） 6. 数据立方体（……） 在数据立方体中找到一个合适的维度（子集）与层次 维度的粒度也可自己决定 对数据立方体进行处理 不进行物化 只保留基子方体，粒度最细，需要其它视图时就实时计算 全物化 后台只有多维模型，单OLAP，全算 混合OLAP，算的结果放在数据库或星型模型中 计算、存放资源浪费 部分物化 冰山方体 挑选依据： 整个数据立方体中进行物化需要的资源是多少 不怎么占用资源，实时在线算也可，就不一定需要物化 物化带来的效果 物化也可以有层级 0-D可以基于2-D而不一定基于4-D（方体格中） 7. 多维数据分析 定义：对以多维形式组织起来的数据进行一系列操作后分析 操作： 切片 切掉不关心的数据 切块 旋转 上钻 关注对象仍是本人，但层次上升 细节信息被抹去，信息被概括 视图–&gt;另一个视图 子方—&gt;另一个子方 3D — 2D是一种上钻（某个维度被上升为All 下钻 特例：引入全新维度 维度从ALL下降到具体 ===&gt; 上钻下钻最消耗资源（要考虑支撑信息能否支持实时在线性 ===&gt; 上钻下钻可以实现是因为方体格中有详细信息 drill across 上面讨论的都是单一的数据类型，但维度可以连接事实表，有几个事实表可能就有几个数据立方体 联合分析多个多维模型中的多个度量值 drill through 基本子方不会放在OLAP服务器上 代价高（数据仓库原子层中就有）、没必要 要用到OLAP服务器上没有的详细数据了呢？drill through 数据仓库的设计1. 由来 vs. 数据库 有一致 有不一致 最大的差异在于构思（概念模型设计） 数据库中：数据流分析 数据仓库中：无数据流分析，按某种主题构思星型模型或雪花模型 数据仓库没有需求驱动 它要支撑所有的分析应用，可能部分分析应用的需求是明确的，但没有评价标准 建造数据仓库的主要两部分 与操作型系统接口（ETL）的设计 数据仓库本身的设计 2. SDLC vs. CLDS SDLC: 需求和数据库中的数据是对应的（需求驱动 数据库被交给应用编程人员时，数据库就算是交付完毕（有错再说 此时数据库为空 数据库优先于应用编程存在 CLDS： 有一些客观存在的数据源，但是没有需求 数据源限定了数据项，可以猜测有什么样的需要 数据仓库被构造出来的标志： 完成第一次ETL，仓库中有数据了 DSS应用编程 可能基于猜测的需求和分析人员的明确/不明确的需求 系统测试： 是否缺失需要的数据 结果是否满意 接下来就可以重新理解需求了 ==需求在后== 3. 设计原则 面向主题 vs. 数据库 建立目的 需要执行的分析操作 数据驱动原则 预先定义数据模型 可以和具体实现毫无关联 原型法设计原则 4. 过程/数据模型与设计环境 基于过程的模型 操作型环境 数据仓库中没有过程 数据模型 操作型、分析型环境都可 企业级数据模型 数据模型的性质 稳定性：较少变更的数据放在快速设备上？经常更改的放在慢速上？？？ 会影响到刷新频率 数据模型与迭代开发 迭代开发 新的数据源（客观变化） 数据模型指示迭代方向 预测数据仓库的主题，将主题划分来决定迭代 设计主题的边界（公共维度 ===&gt; 雪花到星座、雪花到雪暴） 不存在没有关联（通过公共维度能够访问到两个主题）的主题 如果迭代1 2 开发的主题1 2 发现没有关联，可以把迭代9的内容提前，因为主题9连接起了1和2 如果没有上述的调整（监管机构和方式方法），瞎比比挑一个顺序开发，会导致 有重叠（浪费） 不一致和冲突 ===&gt; 另一个数据源 再添加主题时，无法将其设计得与现有的乱糟糟的数据模型兼容 不考虑： 各次迭代的开发团队 团队是否并行 数据仓库设计的三级数据模型 概念模型 //高级模型 E-R 逻辑模型 //中极模型 关系模型（数据库中的二维表） 物理模型 //低级模型 逻辑模型在数据仓库中的实现 数据仓库的设计步骤 系统规划： 明确主题 迭代过程所需要的数据模型 从无到有： 这些主题可能只有一个名称（不需要明确细节 主题可能会交给分析人员，由其增删改，最后汇集到数据仓库的设计人员 设计人员提出公共维度 主题 + 公共维度 ===&gt; 数据模型的最小集合 必须要回答的问题（原型设计法）： 有哪些主题 接口是什么 技术准备 具体的技术要求和物理实现环境 迭代“明确主题”part 数据仓库的设计 生成和运维 概念模型设计 一个分析域中的主题放在一次迭代中 概念模型设计 确定系统边界 确定主要的主题及内容 星型、雪花（广义上来说仍然是E-R OLAP等分析应用的设计 逻辑模型设计 将E-R图转成关系数据库的二维数据表 定义数据源和数据抽取规则 数据库中没有 考虑一些问题 粒度划分 详细数据 || 轻度总结 || 高度总结 没有非常明确的、排他的定义，没有定量差异 不同粒度的表是不兼容的 面向的是事实表 数据分割策略 类似于数据库中的分片 分割谁？按什么分割？ 分割事实表 通常采用时间属性作为数据分割的依据 时间几乎是所有事实表都会有的一个外键 可以预估一张子表的规模、大小 定义数据来源及抽取规则 物理模型设计 优化 合并表 减少表的连接（消耗很大）次数 代价：浪费空间 数据库中要么只有分开的表，要么只有合并表（不允许冗余 数据库中所有表的大小是“一样的” / “等价的” 数据仓库中的访问模式并不固定，合并表可能只能满足一小部分的访问 数据仓库中有两种表：维表、事实表（事实表肯定大于维表 数据序列 还是固定访问某些表，但是并不需要所有的属性，可能只是固定的几张表里固定的几个属性 合并表开销太大而且并没有提高性能 把这些固定的属性挑出来放进一个数据结构中（并不合乎逻辑 但注意数据库不能有冗余吼 引入冗余（狭义上的） 表的物理分割（区分于逻辑模型设计中的分割（切元组、切事实表 纵切：对于一张表格中包含的属性进行切分 访问频率 更新频率 决定资源分配：给经常访问但不常更改的快速访问设备，给不常访问常常更新的数据较慢的设备 拆维表，不拆事实表 ===&gt; 从企业级的数据模型中来，或者从log中分析 生成导出数据 给一个没提到的数据物化以后存放的位置？？ 建立广义索引 记录数据仓库中与“最”有关的数据 数据库中不存在（这是个冗余数据 顶不住啊，索引次数太多辽 在每次ETL时进行刷新 如果不需要实时刷新 小程序 需要实时刷新 限制广义索引的范围 业务领域、管理活动中都有 数据仓库生成 建立数据模式 编制数据抽取程序（ETL） 数据加载 数据仓库的使用与维护 6. 数据仓库的生命周期 数据模型分析 粒度分析 逻辑模型分析 数据量的预估 本来在第二个模型才要考虑的，被提前 技术评估 技术环境准备 主题域分析 数据仓库设计 源系统分析 程序说明 编程 ===&gt; 8 9 == ETL 组织构建与主题的明确多维建模1. 多维建模初步 事实表 维度建模的核心 一个事实表对应一个或一组度量值 表中一行对应一个度量值 每一行的粒度应该相同 粒度划分模型 事实表中的度量值 基数很大 基数往往和提供的信息量大小成正比 非文本、枚举、bool等 最常用：数值类型 可以连续取值 三种类型的度量值 可加 可沿某些维度加 不可加（一般不会出现这样的度量值 事实表中的关键字 事实表中有上下文 不同于数据库，数据库的上下文是由应用来定义的而不是由表的内容来定义的 数据仓库中，是通过维度表中的维成员连接事实表，拿取度量值进行聚集得到结果，所以没有必要按照独立的关键字对当前事实表进行检索 每张事实表有&gt;=2个外关键字，用于连接到维表 所有外关键字组合构成主关键字 维度表 事实表的入口，是提供给用户的数据仓库的接口 列用于区分维成员 越多的属性（列）可以越精确地区分维成员 因此维度表的定义通常包括尽可能多的列 维度属性 通常是文本数据或离散数据 使用区间 少使用编码属性（直接用文本描述 数据库中常用编码加速 数据仓库不需要快 问题：当前分析人员能否正确还原编码？（歧义 面向的人员不同（数据库的使用人员是程序员嘿 vs. 度量值属性 事实与维度的融合 2. 多维建模案例 维度建模的设计过程 选取要建模的（分析型）业务处理过程 从零开始：大部分的“需要”是“猜测” 迭代过程：斟酌之前的“需要” 选择事实表中的维度 事实表中的维度表 事实表专有维表，是当前事实表的特定维度，不与其它事实表有关联 公共维表，在多个事实表中进行共享（在进行维度建模前就已经建立（总线（不隶属于维度建模过程，只需要决定要引入哪些 与私有维度无关 2.1 零售营销 需求分析 数据驱动 面向主题 主题不需要很详细，后续会细化修改 维度建模的设计过程 选定维度 日期、商场、产品是从总线中挑选出来的 促销维度是新建的 确定事实 度量值 直接度量值：可以直接从数据源中拿到或通过计算得出 导出型度量值（如毛利润金额 来源于其它度量值，可以放在事实表中，也可以不放，需要用到时现场计算 看存储开销 vs. 计算时间（多长时间被访问一次） 如果不具备可加性，就不需要放置在事实表中 维度设计 前面就应该做好 多级体系划分属性，多对一对应关系，数据量越来越小 分析的角度是组合维度而并非互斥（独立维度） 如果真的是互斥角度，则放在一个维表里会造成空间浪费和分析困难，应该独立出每个维度来，但是没有了组合的概念 会给事实表引入更多的外键（事实表的元组肥肠多，相比之下多出来的空间比我之前放在一起浪费的维度多多了×） 数据仓库中维度不能为null为空 null || 空无法进行连接 使用特殊行来表示null ===&gt; 准确的外关键字 所有用这个特殊外关键字来连接到事实表的都认为该维度为空 存在问题：只存放关心的东西 事实表中只有进行促销并且卖出去的商品，那进行促销但没卖出去的呢？（即本事实表关心的是卖出去的促销商品，以此分析促销对于商品销售的影响 在数据库中没有问题，因为这个说明数据库就是用来记录卖出去的促销商品的 但数据仓库应该支持各种各样的分析需求 需要一个非事实型事实表——促销记录 没有分析价值——没有度量值 需要其它事实表联合分析 为什么不直接放进事实表？ 粒度不同 非事实型事实表中：只要有一个促销组合（组合是上面的概念），就会加入 退化维度 库存事务 库存快照无法提供的分析（为什么需要库存事务）： 无法区分一天之内入库又出库的情况和一直没有入库的情况 无法知道入库的具体情况 分多少次入库 何时入库 ===&gt; 可能会导致运输成本的变动，这是需要分析的点 ===&gt; 当前周期快照粒度过大，无法进行细节性分析 ===&gt; 需要事务性粒度的数据 库存事务类型维度 库存事务的私有维度 库存事务类型组： 按各种标准拆分事务 但数据粒度过细，数据量会增大，要回答一些简单的分析问题时不如库存快照 库存快照和库存事务结合使用（如果两种分析都需要） 库存累积快照 入口事件发生就增加一个元组，所有度量值设为不可用 一个元组中并非所有事件都会发生，如果记录终止在了某个事件上，那么这个事件之后的事件都是“永不发生” 改善库存事务查询普通分析的要求数据时效率过低问题（表的连接过多） 有效加速对于重要采购记录的访问速率 需要的存储空间很大 但进入这个累积快照的数据是有门槛的（重要数据）（大白菜咋了大白菜不好吃啊） 何时认为快照已经被完全构造出来了？ 没有任何一个FK指向“尚未发生” 所有日期类型的FK指向固定日期或“永不发生” 主题的集成 主体之间的维度共享 连线关系为引用关系 ===&gt; 总线结构 数据仓库的总线 总线结构独立于多维建模，事先就被创建好 数据仓库总线矩阵 行：若干个主题或主题细分 列：公共维度 可以确定维度和哪些主题相关，设计该维度时就可以更全面，而不是多次迭代修改数据结构 尽管主题的详细信息都还未知 主题分多次迭代 相关的主题放在一次迭代中 ===&gt; 重叠的公共维度较多 可以根据一次迭代中的主题来决定哪些维度先设计","link":"/2021/12/21/BI/"},{"title":"BFC","text":"定义BFC(Block formatting context) 直译为”块级格式化上下⽂”。它是⼀个独⽴的渲染区域，只有Block\u0002 level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相⼲。 可以理解为 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 Formatting Context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 形成满⾜以下任意⼀个条件可以创建⼀个新的BFC： 根元素 脱离普通⽂档流的元素（浮动、绝对定位、固定定位），position的值不是static或者relative ⾮块级元素（display属性值是inline-block、table、flex） overflow属性值不为visible的块级元素 布局规则 内部的Box会在垂直⽅向，⼀个接⼀个地放置 Box垂直⽅向的距离由margin决定，属于同⼀个BFC的两个相邻Box的margin会发⽣重叠 每个盒⼦（块盒与⾏盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 BFC的区域不会与float box重叠 BFC就是⻚⾯上的⼀个隔离的独⽴容器，容器⾥⾯的⼦元素不会影响到外⾯的元素。反之也如此 计算BFC的⾼度时，浮动元素也参与计算 作用清除浮动如果父元素没有设置高度，其子元素均为浮动元素，此时父元素会发生高度坍塌 计算BFC的高度时，浮动元素也参与计算 因此使父元素形成BFC即可清除浮动，css3新增属性可以直接触发BFC 1display: flow-root 解决浮动元素覆盖问题兄弟元素设置浮动会产生覆盖问题 BFC的区域不会与float box重叠 使蓝色块触发BFC，即可解决覆盖问题","link":"/2021/10/23/BFC/"},{"title":"响应式web布局","text":"响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。 优点 面对不同分辨率设备灵活性强 能够快捷解决多设备显示适应问题 ⽹站可⽤性得到提升，同时与移动优先设计以及内容策略能够⾮常好的融合在⼀起 简化服务器端 只提供⼀个⼊⼝给搜索引擎 能够⽀持未知设备 缺点性能 兼容各种设备⼯作量⼤，效率低下 代码累赘，会出现隐藏⽆⽤的元素，加载时间加⻓ 限制应用的复杂性 折衷性质的设计解决⽅案，多⽅⾯因素影响⽽达不到最佳效果 ⼀定程度上改变了⽹站原有的布局结构，会出现⽤户混淆的情况 方案媒体查询媒体查询可以让我们针对不同的媒体类型定义不同的样式，当重置浏览器窗口大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面 12345678910111213141516171819202122232425262728293031323334353637383940/* iphone6 7 8 */body { background-color: yellow;}/* iphone 5 */@media screen and (max-width: 320px) { body { background-color: red; }}/* iphoneX */@media screen and (min-width: 375px) and (-webkit-device-pixel-ratio: 3) { body { background-color: #0FF000; }}/* iphone6 7 8 plus */@media screen and (min-width: 414px) { body { background-color: blue; }}/* ipad */@media screen and (min-width: 768px) { body { background-color: green; }}/* ipad pro */@media screen and (min-width: 1024px) { body { background-color: #FF00FF; }}/* pc */@media screen and (min-width: 1100px) { body { background-color: black; } 缺点：如果在浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。 百分比布局通过百分比单位，可以使得组件的宽和高随着浏览器的高度的变化而变化，从而实现响应式的效果 不建议 ，各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。 remrem是相对于根元素html的font-size大小的单位 使用rem单位设置元素高度和宽度，再利用媒体查询，在分辨率发生变换时，给跟元素不同的font-size即可实现响应式布局 123456789101112131415@media screen and (max-width: 414px) { html { font-size: 18px }}@media screen and (max-width: 375px) { html { font-size: 16px }}@media screen and (max-width: 320px) { html { font-size: 12px }} 其他 Flex弹性布局，兼容性较差 flex弹性布局学习总结 Grid网格布局，兼容性较差 CSS Grid 网格布局教程 Columns栅格系统，往往需要依赖某个UI库，如Bootstrap bootstrap4之栅格系统","link":"/2021/10/27/Responsive-Web/"},{"title":"商业模式类型","text":"讨论建筑风格的意义在于捕获建筑设计的理念，将其作为典型的、可重复使用的描述 分拆商业模式 企业内部的三种活动驱动因素不同，彼此之间冲突，企业内部消长 通过分拆使其各自独立 背景 包含基础设施管理、产品创新以及客户关系管理于一体的模式 挑战 成本过高 若干相互冲突的组织文化共存于同一实体中，产生不良的消长 解决方案：将企业解绑，分为三块独立但互补的模式 基础设施管理（经济） 新产品开发（竞争） 客户关系管理（文化） 理论依据 信息技术以及管理工具的改善，使得不同企业独立但相互协作的商业模式获得更低的运营成本，从而消除了不良的消长 案例 私人银行 移动通信运营商 可口可乐 开放的商业模式 企业的研发的流程对外敞开 由外到内：将外部的理念、技术或知识产权引入内部 由内到外：将内部的知识产权或技术，特别是闲置资产向外出售 背景 研发资源和关键活动都聚焦在企业内部 理念全数来自“内部” 成果全数用于“内部” 挑战 研发活动成本高，且效率低 解决方案 内部研发资源和活动因得到外部合作者的使用而被激活 内部研发成果转化为价值主张并提供给感兴趣的客户群体 理论依据 从外部渠道获得研发成果可能成本更低，并缩短产品上市的时间。将未利用的创新成果向外部销售，从而可能带来更多的收益 案例 宝洁 多边平台商业模式 多边平台将两个或更多独立但相互依存的客户群体进行连接 平台对于其中某一客户群体的价值来自于其他群体的存在 平台通过促进不同群体之间的互动而创造价值 一个多边平台价值的提升在于它所吸引的用户数量的增加 背景 一个价值主张只针对一个客户群体 挑战 企业无法获得潜在的新客户，这些新客户对于公司的既有客户群体十分感兴趣 例如，游戏开发商希望能够得到游戏机玩家 解决方案 提出新的价值主张，使得一家企业的既有客户群体让人“够得到” 例如，游戏机生产商为自己的软件开发商提供与游戏机用户的沟通渠道 理论依据 作为媒介以平台方式沟通两个或多个客户群体，为原有的商业模式增加了收益来源 案例 谷歌 任天堂、索尼、微软的电子游戏机 苹果公司iPod、iTunes以及iPhone 免费的商业模式 至少有一个关键的客户群体可以持续免费地享受服务 通过其他方面补贴免费产品 可行方式 基于广告 免费增值 诱饵&amp;陷阱 背景 高价值、高成本的价值主张，只面向付费客户提供 挑战 高价格让客户望而却步 解决方案 面对产生不同收益流的不同客户群体，提供不同的价值主张，其中一种是免费模式（或低成本模式） 理论依据 用付费客户群体来补贴免费客户群体，从而吸引最大数量的用户 案例 广告和报纸 开放源码 红帽公司 长尾商业模式 提供相当多种类的小众产品，每类卖出量相对很少，但汇总的销售收入可以与传统模式销售媲美 背景 价值主张只针对最能产生利润的客户 生产工具的普及：文字发布、视频录制、生产与设计外包 销售渠道的普及：互联网 连接供需双方的搜寻成本降低：搜索、推荐、用户评级、社区 挑战 针对利润较小的群体设置不同的价值主张，成本过高 解决方案 这种新的或者说附加的价值主张针对的是之前看来利润较小的那一大部分群体，小众客户群体总体而言是盈利的 理论依据 信息技术以及运营管理方法的改善使得定制化的价值主张得以面向大量的新客户，并且以低成本实现 案例 出版行业 乐高 netflix","link":"/2021/10/24/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B/"},{"title":"商业模式画布","text":"商业模式定义一个商业模式描述的是一个组织创造、传递以及获得价值的基本原理，其本质在于价值的流动 围绕商业模式的基本活动 画布：基本模型与工具 类型：利用画布分析常见的商业模式 设计：商业模式的构建手段 战略：商业模式的环境、评估、规划、管理 流程：完整的商业模式设计流程 商业模式画布情感端客户细分Customer Segments企业想要获得的和期望服务的不同的目标人群与机构 细分条件 需求催生新供给 需要新分销渠道和客户关系模型 产生的利润率不同 愿意为某方面的特殊改进买单 划分方式举例 大众市场：强业务特征 小众市场：其价值主张、分销渠道、客户关系聚焦于一个庞大的、有着广泛的相似需求和问题的客户群 求同存异的客户群体：某业务下基于客户共性的细分 多元化客户群体：服务于两个需求和问题迥异的客户群体 多边平台/市场：服务于两个或 多个相互独立的客户群体 价值主张Value Proposition为客户群体提供能为其创造价值的产品与服务，价值主张是客户选择一家公司而放弃另一家的原因 有益于价值创造的因素 创新：价值主张满足客户之前未曾察觉的新需求 性能：改进产品或服务的性能 定制：针对某些客户或客户群体的某项需求提供定制的产品或服务 保姆式/一站式服务：简单地帮客户完成任务 设计 品牌/地位：客户可以简单地通过使用和展示某一品牌而获得价值 价格：以更低的价格提供相同的价值是满足价格敏感型客户群体的需求的普遍方式 缩减成本：帮助客户节约成本是创造价值的重要方式 风险控制：为客户购买的产品或服务降低风险 可获得性：帮助客户获得之前他们无法获得的产品和服务 便利性/实用性：让产品使用起来更方便或操作起来更简单 渠道通路CHannels一家企业如何同它的客户群体达成沟通并建立联系，以向对方传递自己的价值主张 作用 了解产品与服务 评估价值主张 购买产品与服务 传递价值主张 提供售后支持 五个阶段 知名度：我们如何扩大公司产品和服务的知名度？ 评价：我们如何帮助客户评价我们的价值主张？ 购买：客户如何能够购买到我们的某项产品和服务？ 传递：我们如何向客户传递我们的价值主张？ 售后：我们如何向客户提供售后支持？ 客户关系Customer Relationship一家企业针对某一个客户群体建立的客户关系的类型 动机 开发新客户 留住原客户 增加销售量或单价 类型 私人服务：基于人际互动。客户可以与客户代表进行交流并在销售过程中以及购买完成之后获得相应的帮助 例：商场导购 专属私人服务：要求为每一个客户指定一个固定的客户经理 例：私人银行服务 自助服务：企业无需直接维护与客户的关系，只需为客户提供一切自助服务所需要的渠道 例：ATM 自动化服务：将相对复杂的客户自助服务形式与自动化流程相结合 例：各类平台推荐系统 社区：企业使用用户社区来融入客户以预判市场未来发展的方向，帮助更好地了解客户 例：小红书 客户共同创造：超越传统的买卖关系，与客户合作共同创造价值 例：B站 收入来源Revenue Streams企业从每一个客户群体获得的先进收益 方式 资产销售：实物产品所有权的出售 例：亚马逊 使用费：对某种具体服务的使用 例：话费 会员费：向客户销售某项服务持续的使用权限 例：健身卡 租赁：将某一特定资产在某一个时期专门供给某人使用并收取一定费用 例：共享单车 许可使用费：向用户授予某种受保护知识产权的使用权，并向其收取许可使用费 例：专利授权 经纪人佣金：向双方或多方提供的中介服务 例；房产中介佣金 广告费：为某种产品、服务或品牌做广告的费用 理性端核心资源Key Resources保证商业模式顺利运行所需的最重要的资产 类型 实物资源 例：生产设备、房屋、车辆、机器 知识性资源 例：品牌、专营权、专利权、版权 人力资源 对于创新性和知识密集产业最重要 金融资源 例：车贷 关键业务Key Activities保证商业模式顺利运行所需做的最重要的事情，于价值主张强相关，价值主张的具象化 类型 生产：设计、制造以及分销产品 例：制造企业 解决方案：包括知识管理和持续的培训 例：咨询公司 平台/网络：涉及平台管理、新服务的启动以及平台的升级 例：eBay、visa 重要合作Key Partnership保证一个商业模式顺利运行所需的供应商和合作伙伴网络 类型 非竞争者之间的战略联盟 竞争者之间的战略合作 新业务的合资公司 稳定供应关系的供应商和采购商 合作动机 优化与规模效应：降低成本，外包或共享基础设施 特殊资源及活动的获得：高技术产品、销售团队、特许商品 降低风险和不确定性 成本结构Cost Structure运营一个商业模式所发生的全部成本 导向 成本导向：成本最小化，创造并维持极尽精简的成本结构 价值导向：高端的价值主张与高度的个性化服务 特点 固定成本：不因产品及服务的产量而改变的成本 例：管理员工工资、租金、生产设备 可变成本：随着产品及服务的产量而同比例变化的成本 例：广告推广费、水电、原材料消耗 规模经济：企业的产出扩大，会带来成本优势 例：大宗采购，大规模生产摊薄的固定成本 范围经济：企业的经营范围扩大，会带来成本优势 例：同一个营销活动或分销渠道上可以供多个产品使用 画布模块之间的联系 纵向联系 客户关系 -&gt; 渠道通路 -&gt;收入来源 关键业务 -&gt; 关键资源 -&gt;成本支出 跨越的联系 客户关系选择与成本支出导向（定制化、个人化 – 价值导向 VS 自动化、大众化 – 成本导向） 建设渠道通路所需的核心资源与重要合作 细分的客户群体是否认同上游的重要合作方与引入的外部关键资源？ 联系的联系 平台：多个“价值主张-客户细分”对的组合才能构成完整的收入来源","link":"/2021/10/07/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%94%BB%E5%B8%83/"},{"title":"商业模式设计","text":"工具、方法、思维 设计的三个相互重叠的空间：灵感、构思、实施 客户洞察 客户视角是商业模式的指导性原则，客户的观点决定了我们选择怎样的价值主张、渠道、客户关系和收益来源 客户洞察的难点 透彻理解客户（ “问题背后的问题” ）；需要人类学、社会学理论（笼统的人），以及与实地调研（具体的人）结合； 清楚了解企业当前关注哪些客户（的需要），忽略哪些客户（的需要）— 需要有所取舍 辅助工具：移情图 罗列所有客户群体，挑选三个最有希望的，选择一个作为分析对象 构成 看：描述该客户在她所处的环境中所看到的东西（她眼中的产品、周边的人与朋友、能接触到的同类产品、遇到的困难） 听：描述环境如何影响到这个客户（她朋友说了什么、配偶说了什么、哪些人以怎样的方式真正影响到她、有影响力的媒体渠道） 说&amp;做：想象客户可能的言辞，或公共场合的行为（持有的态度、对他人的言论、要重视真实想法与外部言论之间可能的矛盾） 想&amp;感受：尝试勾勒你的客户思维的过程（哪些事情是真正重要的、她的情绪与可能的触动、夜不能寐的事、梦想与渴望） 痛点：已遭受的挫折、正遇到的阻碍、怕承担的风险 收益：预期成就、成功衡量标准、实现目标所采用的策略 场景 两种场景 不同的客户结构：结合客户洞察描绘出独特、具体的图景 未来可能的竞争环境；想想未来可能的具体细节，品味特定条件下商业模式如何演进 为一个故事设计并补充场景 了解与评估 购买与传递 交互 售后 评价与复购 构思 概念：一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程 两个步骤：生成大量创意 -&gt; 对创意进行整合并挑选 提出新创意的两个出发点 从画布中寻找创新的焦点 资源驱动 创新来源于组织现有的基础设施或合作伙伴资源 例：亚马逊云计算服务 供给驱动 创造全新的价值主张，并影响到其它模块 例：墨西哥水泥厂商Cemex承诺4小时内将水泥送到 客户驱动 基于客户需求、可获得性或便利性的提升，并影响其他模块 例：23andMe为个人客户提供DNA测试服务 财务驱动 由新收益来源、定价机制或者被缩减的成本驱动的创新 例：施乐公司提供复印机租赁 多点驱动 多焦点驱动的创新，并对其它模块产生深远影响 例：Hilti向客户出租建筑工具 不断提出“如果…会怎样”的问题 用此类问题打破在设计过程中遇到的现有商业模式的束缚，并使更多新奇的、难以执行的主张闯入我们的思维 例：“如果学生因为疫情无法到校又要求不停课怎么办？” 流程 团队组建 关键问题：为了产生新颖的商业模式创意，我们的团队是否足够多样化？ 组建正确的团队对产生有效的新商业模式创意至关重要 钻研 关键问题：在生成商业模式创意之前，我们必须钻研哪些知识？ 钻研阶段包括总体研究、研究客户与潜在客户、详细调查新技术、评估现有商业模式 开拓 关键问题：我们能针对商业模式的每个模块做哪些创新？ 从九大模块任意一点出发作为创新起点；数量是关键；重在创意，避免过早评论价值 甄选标准 关键问题：我们为商业模式创意排序最重要的标准是什么？ 需要涵盖：预期实施时间、潜在收入、可能的客户阻力、对竞争优势的影响 构建模型 关键问题：对于每一个进入短名单的创意，它完整的商业模式会是怎样的？ 确立标准后，团队从创意中整理一个最优短名单，由此构建3-5个创新的商业模式，再利用画布进行勾勒和讨论 头脑风暴 规则 保持聚焦：精确表达当前问题、始终与客户需求有关、不要跑题太远、将讨论拉回到开始问题 执行规则：坚决执行开始时的规则：“不过早下结论”、“每次一人讲“、”追求数量”、“可视化”、“疯狂创意” 视觉化思考：将创意写或者画在每个人都能看到的地方：便利贴+黑板/墙 准备：为一次头脑风暴所准备的钻研：技术研讨、实地考察、客户讨论等各种形式 无声的头脑风暴、笨牛训练 视觉化思考 价值 抽象的东西具体化、复杂的概念简单化 视觉化能够一目了然的刻画商业模式的主旨，并具象化其中的隐含假设 视觉化能够使商业模式变的明确，为团队讨论提供一些概念性的锚点，使讨论从抽象思维落实到具体、形象的东西 视觉化既能找出已有模式中的逻辑缺陷，又能在设计全新模式时更容易地添加、删除和移动相关的图片化概念 两项技术 如何使用便利贴 + 如何将草图与商业模式画布结合 四个流程 理解、对话、探索、沟通 实现 便利贴 + 绘画 作用 理解商业模式的本质 提升对话效率 探索创意 提升沟通 如何讲述视觉化故事 绘制商业模式 用简单的文字填充各个商业模式模块，一个模块只用一张便利贴 用图形描绘每个商业模式元素 每次取下一张便利贴，再用图形去取代文字想表达的内容，图形保持简单 设计故事主线 决定讲故事的时候先贴哪张便利贴；可以尝试不同的主线与起点，只要能支撑故事 讲述故事 根据便利贴的顺序与贴图的内容逐一讲述你的商业模式 模型构建 这里的“模型”：用于讨论、探究或概念验证的工具，目标是探索未来潜在的商业模式（不等于软工领域的模型或原型），可以是草图、画布或财务报表 价值 与视觉化思考一样，模型构建可以使抽象的概念具体化，帮助探索新的创意 模型构建有助于实际商业模式的探索 建模-（疑问点明确化、视觉化）-添加、删除或修改元素-观察结果 在不同规模（抽象层面）的模型上进行互动 有助于获得突破性的商业模式，同时能够有效控制细节 设计态度：专注探索，全面考虑，快速放弃，选出值得优化的想法，接受不确定性 控制规模：通过绘制很多（粗略的和细致的）模型来代表各种战略选择，再通过对每个模型添加和移除元素的方式来探索新想法 随手素描：勾勒和推销一个粗略的主意（含价值主张和主要收益来源） 勾勒想法，含价值主张和主要收益来源 精心描绘的画布：探索实现该创意所需的因素 完整画布，商业逻辑思考，市场潜力预估、理解模块之间联系、“事实查证” 商业案例：检查该创意的可存活度 全面画布，关键输入、核算成本与收入、估算利润潜力、模拟财务场景 实地验证：调查客户的可接受度和可行性 准备合情合理的商业案例，站在客户角度进行实地验证，验证价值主张、渠道、定价机制等实际市场中的元素 模型，不求精细，胜在快速 早期的模型应该是快速的、粗糙的、便宜的 适可而止：模型的目的是赋予想法具体的外形，了解该想法的长处和弱点，从而为更详细、更精密的下一代模型寻找方向（最终转向具体设计） 讲故事 价值 故事是一个理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备 将故事与画布结合，利用叙事性克服听众对不熟悉模式的抵触，放下对陌生事物的怀疑 目的 介绍新想法：尝试融入组织战略 向投资人推销：争取外部资源（是什么，为谁服务，如何获得收益） 吸引员工（成员）：抓住组员的注意力和好奇心，为下一步探讨准备 让未来触手可及：激发创意、辩证变革 开头方式 公司视角 客户视角 方法 图片和旁白 视频 角色扮演 文字和图片 连环图画","link":"/2021/11/07/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"title":"商业模式评估","text":"商业模式环境评估市场影响力 市场问题：从客户和供给的角度识别出驱动和改变你的市场的关键问题 影响客户环境的关键问题有哪些？ 哪些改变正在发生？ 市场将走向何处？ 市场分类：识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体 哪些是最重要的客户群体？ 哪个群体的增长潜力最大？ 哪些群体在缩小？ 哪些边缘群体值得留意？ 需求和诉求：列举市场需求并分析这些需求被满足的程度 客户需要什么？ 没有被满足的客户需求里哪个最值得关注？ 客户真正想要搞定什么？ 哪些需求在增加？ 哪些需求在减少？ 切换成本：客户一旦转投竞争对手，哪些方面需要改变 哪些东西将客户捆绑在一家供应商和它的服务上？ 哪些切换成本组织客户转投竞争对手？ 客户容易找到并采购类似的服务吗？ 品牌有多重要？ 收入吸引力 识别与收入吸引力和定价能力相关的因素 客户真正愿意花钱买的是什么？ 利润中最大的一块从哪里获得？ 客户能够轻易地找到并购买更便宜的产品和服务吗？ 关键趋势 技术趋势：识别威胁到你的商业模式的技术趋势，以及能推动你的商业模式进步的技术趋势 你的市场内外的主要技术趋势有哪些？ 哪些技术代表了重要的机会或者颠覆性的威胁？ 哪些新兴技术是边缘客户正在逐步采用的？ 行业管理趋势：描述影响你的商业模式的管理规定和管理趋势 描述关键社会趋势 文化或社会价值观上的哪些变化会影响你的商业模式？ 哪些趋势会影响购买者的行为？ 社会和文化趋势：识别可能影响你的商业模式的社会趋势 描述关键社会趋势 文化或社会价值观上的哪些变化会影响你的商业模式？ 哪些趋势会影响购买者的行为？ 社会经济趋势：总结和你的商业模式有关的主要社会经济趋势 关键的人口统计学趋势有哪些？ 你的市场中收入和财富的分布有哪些特征？ 描述你所处市场的消费特征（比如住房、医疗、娱乐等） 城镇人口相对于农村人口的比例如何？ 行业影响力 （现有的）竞争对手：识别现有竞争对手和他们的相对优势 谁是我们的竞争对手？ 哪些是我们这个领域的主流玩家？ 他们的竞争优势或劣势是什么？ 描述他们的主要产品和服务 他们聚焦哪些客户群体？ 他们的成本结构如何？ 他们对我们的客户群体、收益来源和利润有多大影响？ 新进入者（挑战者）：识别新的、突然出现的玩家，并且审视他们的商业模式是否与你的不同 谁是你所处市场的新进入者？ 他们之间有什么不同？ 他们有什么竞争优势或劣势？ 他们必须克服哪些障碍？ 他们的价值主张是什么？ 他们聚焦哪些客户群体？ 他们的成本结构是什么样的？ 他们对我们的客户群体、收益来源和利润有多大程度的影响？ 替代产品和服务：描述你的产品和服务潜在的替代品，包括那些处于其他市场和行业的产品与服务 哪些产品和服务能够替代我们的产品和服务？ 它们的成本与我们相差多少？ 客户要切换到这些替代品有多容易？ 这些替代产品起源于何种商业模式传统（例如，高速列车挑战飞机，手机挑战照相机） 供应商和价值链上的其他厂商：描述你的市场价值链中现有的关键玩家，并且找出新兴玩家 谁是你的行业价值链中的关键玩家？ 你的商业模式在多大程度上依赖其他这些玩家？ 有边缘玩家在涌现吗？ 哪个的利润最高？ 利益相关者：识别出哪些人会影响你的组织和商业模式 哪些利益相关者会影响你的商业模式？ 股东的影响力如何？员工呢？政府呢？游说者呢？ 宏观经济影响 全球市场情况：从宏观经济角度总结当前整体情况 经济处于爆发期吗？ 描述总体市场情绪 GDP增长率是多少？ 失业率有多高？ 资本市场：描述与你的资本需求相关的当前资本市场情况 资本市场处于什么状态？ 在你所处的市场中，获得投资有多容易？ 现在就能获得种子资本、创业资本、众筹、市场资本或者贷款吗？ 获取这些投资的成本有多高？ 大宗商品和其他资源：关注你的商业模式所需的资源和当前价格和价格趋势 描述你的业务必备的大宗商品和其他资源的当前市场状态（比如原油价格和劳动力成本） 执行你的商业模式所需的资源（比如吸引主要人才）有多么容易获取？成本如何？价格走向如何？ 经济基础设施：描述你的业务市场的经济基础设施 你所处的市场的（公共）基础设施有多优良？ 你如何评价交通、贸易、学校质量，以及连接供应商和客户的便利度？ 个人和企业的税费有多高？ 对商业组织的公共服务有多好？ 你如何评价这里的生活质量？ SWOT评估优势和劣势（SW） 价值主张评估 成本/收入评估 基础设施评估 客户界面评估 机会（O） 价值主张中的机会（整合、服务化与拓展） 价值主张：产品与服务能否整合，产品能否服务化？价值主张的补充和外延？满足客户的额外需求或其它可做的工作？ 成本/收入中的机会（可重复、交叉销售、开源节流） 收入来源：重复性收入代替一次性收入、寻找额外买单元素与交叉销售的机会、新的收益来源、能否提价 成本结构：成本削减 基础设施中的机会（强化核心、减轻负担、转让闲置） 核心资源：核心资源的降本、外包、强化、转让（降本增效、技术壁垒、技术转让） 关键业务：标准化、IT技术带来的整体效率提升 重要合作：外包与核心业务聚焦、交叉销售与更好的客户连接、价值主张补充 客户界面的机会（增长的市场、客户细分、渠道优化与去中间商，客户关系加强与取舍） 客户细分：找到增长的市场并从中获利、服务新客户群体或更细致的已有客户分类 渠道通路：渠道的效率、效益、整合，补充性的渠道伙伴，去中间商、渠道客户匹配 客户关系：加强与客户的关系并提升客户跟进的效果、定制化或可自动维护、提升切换成本、是否抛弃没有利润的客户以及原因 威胁（T） 对价值主张的威胁（可替代性） 产品是否可替代？ 是否会被更有竞争力的价格或更好的价值取代？ 对成本/收入的威胁（利润的威胁、是否单一、缩水、无法预测、无法支撑） 受威胁的利润？是否是技术原因导致？ 是否过度依赖某一项或多项收益来源？ 未来可能消失（或缩水）的收益来源？ 是否有无法预测的成本？（对宏观经济形势的依赖，供应链的稳定性，负面事件的影响与公关） 哪些成本的增加会快过它们所支撑的收入？ 对基础设施的威胁（供应不足、干扰、合作关系波动） 核心资源：某些资源的供应短缺？资源的质量是否有保证？ 关键业务：哪些关键业务会被打扰 ？我们的活动质量能否保证（产品、渠道）？ 重要合作：可能失去的合作伙伴？是否会跟竞争对手合作？是否过分依赖某些合作伙伴？ 客户界面上的威胁（市场竞争、渠道威胁、客户关系恶化） 客户细分：市场是否很快饱和？市场份额被友商威胁？客户转投的可能性？竞争白热化的速度？ 渠道通路：竞争对手是否威胁渠道？（恶意举报）是否存在渠道与客户不相关的危险？ 客户关系：我们的客户关系有可能恶化吗（产品质量与特性无法支持品牌构建）？","link":"/2021/11/20/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E8%AF%84%E4%BC%B0/"},{"title":"JS浮点数精度(转载)","text":"转载自https://zhuanlan.zhihu.com/p/73699947 众所周知，JavaScript 浮点数运算时经常遇到会 0.0000000001和0.99999999这样奇怪的结果，如 1.07*10 = 10.700000000000001。但是，往往当我们遇到问题之后才想起来浮点数对我们造成的负面影响，如果能提前避免，不是更好吗？ 常见的几种场景场景一：进行浮点值运算结果的判断 常见错误写法：floatNum1 + floatNum2 === res 我们在Chrome里测试一下 0.1 + 0.2 === 0.3，得出的结果是false，而不是预期结果true，因为 0.1 + 0.2 === 0.30000000000000004 场景二：将小数乘以10的n次方取整（比如将元转化成分） 常见错误写法：parseInt(yuan*100, 10) 我们在Chrome里测试一下 parseInt(0.58*100, 10)，得出的结果是57，而不是预期结果58。 场景三: 四舍五入保留n位小数 常见错误写法： (number).toFixed(2) 我们在Chrome里测试一下 (1.335).toFixed(2) ，得出的结果是1.33，而不是预期结果1.34。 可以发现，稍有不注意，浮点数运算就会出问题，那么我们如何解决、防范以上问题呢？ 常见解决方案因为大家一旦察觉到浮点数精度的负面影响，就会马上想到不同思路的解决方案，因此本文的目的是希望大家引起对浮点数的重视，尤其是在计算金额这种需要高严谨数据的枪框下，而非重点介绍解决方案，所以，这一部分就不详细展开了。 大概就是将浮点数转化成字符串，通过String.split取出小数点前后的数据再做特殊处理。当然也有现成的库可供选择，如 number-precision。 那么下面我们详细了解一下为什么会出现这种奇怪的现象呢？ 浮点数的存储JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。64位比特又可分为三个部分： 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 实际数字就可以用以下公式来计算： 注意以上的公式遵循科学计数法的规范，在十进制中 0&lt;M&lt;10，到二进制就是 0&lt;M&lt;2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。比如4.5 转化成2进制就是 100.1。 不知道怎么转换的同学可以查看 二进制十进制间小数怎么转换 。 用二进制对应的科学计数法就是 1.001*2^2，舍去1后M=001。 因为指数位E有 11 位，是一个无符号整数，取值范围是 0 到 2047（2047 = Math.pow(2,11)-1）。但是科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，[0,1022] 表示为负，[1024,2047] 表示为正。如 4.5 的指数 E = 1025（1025 = 1023+2），尾数 M = 001。 最终的公式变成： 所以 4.5 最终表示为（S=0、M=001、E=1025） 4.5二进制 图片由 http://www.binaryconvert.com/convert_double.html 生成。 下面再以 0.1 为例解释浮点误差的原因，0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011…。最终就是： 0.1二进制 转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。 那么下面我们再回到应用场景中的例子，通过二进制数据查看究竟为什么会出现问题： 为什么 0.1+0.2=0.30000000000000004？123456// 0.1 和 0.2 都转化成二进制后再进行运算 0.00011001100110011001100110011001100110011001100110011010 + 0.0011001100110011001100110011001100110011001100110011010 = 0.0100110011001100110011001100110011001100110011001100111 // 转成十进制正好是 0.30000000000000004 为什么(1.335).toFixed(2)=1.33？因为1.335其实是1.33499999999999996447286321199，toFixed虽然是四舍五入，但是是对1.33499999999999996447286321199进行四五入，所以得出 1.33。","link":"/2021/11/27/JS%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/"},{"title":"BOM","text":"浏览器对象模型(BOM)指的是由Web浏览器暴露的所有对象组成的表示模型。BOM与DOM不同，其既没有标准的实现，也没有严格的定义, 所以浏览器厂商可以自由地实现BOM。 作为显示文档的窗口, 浏览器程序将其视为对象的分层集合。当浏览器分析文档时, 它将创建一个对象的集合, 以定义文档, 并详细说明它应如何显示。浏览器创建的对象称为文档对象。它是浏览器使用的更大的对象集合的一部分。此浏览器对象集合统称为浏览器对象模型或BOM。 windowBOM层次结构的顶层是window对象, 它包含有关显示文档的窗口的信息。某些窗口对象本身就是描述文档和相关信息的对象。 所有全局对象、函数以及变量都会自动成为window对象的成员 全局变量是window对象的属性 全局函数是window对象的方法 在调用window对象的方法和属性时，可以省略window对象的引用 方法 12345678910alert() //显示带有一段消息和一个确认按钮的警告框。confirm() //显示带有一段消息以及确认按钮和取消按钮的对话框。prompt() //显示可提示用户输入的对话框。open() //打开一个新的浏览器窗口或查找一个已命名的窗口。close() //关闭浏览器窗口。setInterval() //按照指定的周期（以毫秒计）来调用函数或计算表达式。clearInterval() //取消由 setInterval() 设置的 timeout。setTimeout() //在指定的毫秒数后调用函数或计算表达式。clearTimeout() //取消由 setTimeout() 方法设置的 timeout。 window对象属性及方法 document即DOM（Document Object Model）对象，通过它，可以访问HTML文档的所有元素。 locationlocation 对象包含有关当前 URL 的信息，常用于重定位 属性 描述 hash 返回一个URL的锚部分 host 返回一个URL的主机名和端口 hostname 返回URL的主机名 href 返回完整的URL pathname 返回的URL路径名。 port 返回一个URL服务器使用的端口号 protocol 返回一个URL协议 search 返回一个URL的查询部分 方法 说明 assign() 载入一个新的文档 reload() 重新载入当前文档 replace() 用新的文档替换当前文档 navigatornavigator 对象包含有关浏览器的信息 属性 说明 appCodeName 返回浏览器的代码名 appName 返回浏览器的名称 appVersion 返回浏览器的平台和版本信息 cookieEnabled 返回指明浏览器中是否启用 cookie 的布尔值 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent 头部的值 方法 描述 javaEnabled() 指定是否在浏览器中启用Java taintEnabled() 规定浏览器是否启用数据污点(data tainting) **Warning!!!**The information from the navigator object can often be misleading, and should not be used to detect browser versions because: Different browsers can use the same name The navigator data can be changed by the browser owner Some browsers misidentify themselves to bypass site tests Browsers cannot report new operating systems, released later than the browser screenscreen 对象包含有关客户端显示屏幕的信息 属性 说明 availHeight 返回屏幕的高度（不包括Windows任务栏） availWidth 返回屏幕的宽度（不包括Windows任务栏） colorDepth 返回目标设备或缓冲器上的调色板的比特深度 height 返回屏幕的总高度 pixelDepth 返回屏幕的颜色分辨率（每象素的位数） width 返回屏幕的总宽度 historyHistory 对象包含用户（在浏览器窗口中）访问过的 URL 属性 说明 length 返回历史列表中的网址数 方法 说明 back() 加载 history 列表中的前一个 URL forward() 加载 history 列表中的下一个 URL go() 加载 history 列表中的某个具体页面","link":"/2021/11/28/BOM/"},{"title":"闭包","text":"一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。 理解 参考MDN闭包相关文档 12345678910function makeFunc() { var name = &quot;Mozilla&quot;; function displayName() { alert(name); } return displayName;}var myFunc = makeFunc();myFunc(); 第一眼看上去，也许不能直观地看出这段代码能够正常运行。在一些编程语言中，一个函数中的局部变量仅存在于此函数的执行期间。一旦 makeFunc() 执行完毕，你可能会认为 name 变量将不能再被访问。然而，因为代码仍按预期运行，所以在 JavaScript 中情况显然与此不同。 原因在于，JavaScript中的函数会形成了闭包。 闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。在本例子中，myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用。displayName 的实例维持了一个对它的词法环境（变量 name 存在于其中）的引用。因此，当 myFunc 被调用时，变量 name 仍然可用，其值 Mozilla 就被传递到alert中。 123456789101112function makeAdder(x) { return function(y) { return x + y; };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12 在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。 从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。 add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。 应用实现私有成员12345678910function base() { let x = 10; //私有变量 return { getX: function() { return x; } }}let obj = base();console.log(obj.getX()); //10 12345678function Foo(name){ this.getName = function(){ return name; };};var foo = new Foo('luckyStar');console.log(foo.name); // =&gt; undefinedconsole.log(foo.getName()); // =&gt; 'luckyStar' 模拟块级作用域1234567for(var i = 0; i &lt; 5; i++) { (function(j){ setTimeout(() =&gt; { console.log(j); }, j * 1000); })(i)}","link":"/2021/11/27/%E9%97%AD%E5%8C%85/"},{"title":"原型与原型链（转载）","text":"转自https://www.jianshu.com/p/ddaa5179cda6 前言与大部分面向对象语言不同，ES6之前中并没有引入类（class）的概念，JavaScript并非通过类而是直接通过构造函数来创建实例。在介绍原型和原型链之前，我们有必要先复习一下构造函数的知识。 一、构造函数构造函数模式的目的就是为了创建一个自定义类，并且创建这个类的实例。构造函数模式中拥有了类和实例的概念，并且实例和实例之间是相互独立的，即实例识别。 构造函数就是一个普通的函数，创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。另外就是调用方式的不同，普通函数是直接调用，而构造函数需要使用new关键字来调用。 1234567891011121314151617function Person(name, age, gender) { this.name = name this.age = age this.gender = gender this.sayName = function () { alert(this.name); }}var per = new Person(&quot;孙悟空&quot;, 18, &quot;男&quot;);function Dog(name, age, gender) { this.name = name this.age = age this.gender = gender}var dog = new Dog(&quot;旺财&quot;, 4, &quot;雄&quot;)console.log(per);//当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值console.log(dog); image 每创建一个Person构造函数，在Person构造函数中，为每一个对象都添加了一个sayName方法，也就是说构造函数每执行一次就会创建一个新的sayName方法。这样就导致了构造函数执行一次就会创建一个新的方法，执行10000次就会创建10000个新的方法，而10000个方法都是一摸一样的，为什么不把这个方法单独放到一个地方，并让所有的实例都可以访问到呢?这就需要原型(prototype) 二、原型在JavaScript中，每当定义一个函数数据类型(普通函数、类)时候，都会天生自带一个prototype属性，这个属性指向函数的原型对象，并且这个属性是一个对象数据类型的值。 让我们用一张图表示构造函数和实例原型之间的关系： image 原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，我们可以将对象中共有的内容，统一设置到原型对象中。 三、原型链1.__proto__和constructor每一个对象数据类型(普通的对象、实例、prototype……)也天生自带一个属性__proto__，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性constructor, 它指向函数对象。 123456function Person() {}var person = new Person()console.log(person.__proto__ === Person.prototype)//trueconsole.log(Person.prototype.constructor===Person)//true//顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 2.何为原型链在JavaScript中万物都是对象，对象和对象之间也有关系，并不是孤立存在的。对象之间的继承关系，在JavaScript中是通过prototype对象指向父类对象，直到指向Object对象为止，这样就形成了一个原型指向的链条，专业术语称之为原型链。 举例说明:person → Person → Object ，普通人继承人类，人类继承对象类 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。 我们可以使用对象的hasOwnProperty()来检查对象自身中是否含有该属性；使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true 123456789function Person() {}Person.prototype.a = 123;Person.prototype.sayHello = function () { alert(&quot;hello&quot;);};var person = new Person()console.log(person.a)//123console.log(person.hasOwnProperty('a'));//falseconsole.log('a'in person)//true person实例中没有a这个属性，从 person 对象中找不到 a 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，很幸运地得到a的值为123。那假如 person.__proto__中也没有该属性，又该如何查找？ 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层Object为止。Object是JS中所有对象数据类型的基类(最顶层的类)在Object.prototype上没有__proto__这个属性。 1console.log(Object.prototype.__proto__ === null) // true 帮你彻底搞懂JS中的prototype、__proto__与constructor（图解）","link":"/2021/12/01/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"},{"title":"改变this指向","text":"1. call方法call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向 应用场景: 经常做继承. 123456789var o = { name: 'andy'} function fn(a, b) { console.log(this); console.log(a+b)};fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3 2. apply方法apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。 应用场景: 经常跟数组有关系 123456789var o = { name: 'andy'} function fn(a, b) { console.log(this); console.log(a+b)};fn()// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3 3. bind方法bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数 如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind 应用场景:不调用函数,但是还想改变this指向 12345678910 var o = { name: 'andy' };function fn(a, b) { console.log(this); console.log(a + b);};var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数 this指向的是对象o 参数使用逗号隔开 4. call、apply、bind三者的异同 共同点 : 都可以改变this指向 不同点: call 和 apply 会调用函数, 并且改变函数内部this指向. call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递 bind 不会调用函数, 可以改变函数内部this指向. 应用场景 call 经常做继承. apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值 bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.","link":"/2022/01/21/%E6%94%B9%E5%8F%98this%E6%8C%87%E5%90%91/"}],"tags":[{"name":"html","slug":"html","link":"/tags/html/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"商务智能","slug":"商务智能","link":"/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"响应式","slug":"响应式","link":"/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"课程","slug":"课程","link":"/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"需求与商业模式","slug":"需求与商业模式","link":"/tags/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"课程笔记","slug":"课程笔记","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","link":"/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"html","slug":"前端/html","link":"/categories/%E5%89%8D%E7%AB%AF/html/"},{"name":"需求与商业模式","slug":"课程笔记/需求与商业模式","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"},{"name":"商务智能","slug":"课程笔记/商务智能","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}]}