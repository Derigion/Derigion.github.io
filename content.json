{"posts":[{"title":"商务智能复习","text":"概要 前继课程 数据库系统原理 关系数据模型 连接 数据库构建的步骤和方法（概念到逻辑 逻辑到物理） 后继课程 数据挖掘 评分 作业30%-40% 考试60%-70% 商务智能的起源 数据库系统的发展 最主要：关系模型 数据层级和业务逻辑的解耦 一份数据可以为多个应用使用 以关系型数据库为基础 数据存放代价越来越低 导致业务系统和信息系统越来越复杂，累积了大量数据（数据库不值钱辣 数据库越来越多，数据会变得越来越定制化 其他倾向（使得数据越来越多）: 计算平台的发展 计算、存储、网络/非网络（物理介质）传输能力 ==采集手段的发展== 基于光学——二维码、图像、视频 传感器、移动设备 RFID（物联网） 👇 ==数据爆炸== 数据、信息、知识 知识值链：数据 数据的意义或信息是由附加在这个数据上的其它内容来说明的，数据本身并不知情 exp： 5000是什么？ price：5000才可以说明问题 在应用开发的阶段，不需要让用户知道数据的意义，只有DBA和对当前数据库做增删改查的业务系统的开发人需要知道这层意义（当然很多情况下他们就是一类人） 知识值链：信息 一系列有关联的数据组合，互相进行解释，使得它们的歧义变得相对更少，得到信息 知识值链：知识 信息中的数据，为什么是这个值，不是其它的值 企业的新问题 企业决策需要 全面了解企业和行业的真实状况 真实状况来自于真实完整的数据 有效将收集的数据转化为信息并最终为企业决策所使用 零售业的EXP： 在复杂零售集团中，有两套业务系统，分别对于统一的和专有的内容进行管理，比如各个部门有自己的系统，但是集团人员的管理是统一的 但是部门太多，每个部门有自己的information workers，每个部门都是摸象的盲人，企业决策者是听取所有摸了象的盲人的报告的盲人，怎么决策？（不能信任任何一个信息工人 要把企业的所有相关情况按照全局方式进行展现👇 数据爆炸、信息贫乏的情况下，要解决信息的： 可访问性 及时性 表达格式 完整性 早期解决方案 第一代：基于主机的查询与报表 只能把少部分信息按照规定的格式推送给决策者 这些报表是有限的数据片段（构不成完整信息体）的有限的信息，过于琐碎，也不完整 第二代：数据仓库 把有限的数据片段聚合，以信息体作为存放单元 仓库中的数据默认统一、一致、完整、”正确“ 为何需要商务智能 如何访问数据仓库？如何利用信息体？ 用机器来做决策？ 商务智能 商务： Buying and selling; commerce; trade 智能（约等于人工智能）：（不适用于商务）（没有规则、没有评估标准） 人工智能：图灵测试、专家系统（典型：人工医疗系统，把西医的专业知识写成概率数据） 目标： 并非解决商务领域的人工智能 改善信息访问 现状：数据分散，而数据仓库中的数据过于完整繁杂 需要精确而概要的数据 仍旧是以人来进行主导： 精力限制 知识背景限制，数据是用来验证猜测的，但知识背景会限制猜测，所以更高级的目标是决策支持 决策支持 只是提供一种支持，比如发现的规律，并非做决策 自动化、半自动化产生输入，决策仍由人来做 比如面包和牛奶高度相关是一个自动化产生的输入，但超市到底应该怎么摆这两样东西，还是由人来决策（而且决策可能完成不一样） 概念：BI是将数据转换为有意义的内容的过程 BI通过把来自于不同系统的数据汇聚成一个单一的可获取的信息源并放入数据仓库（Data Warehouse） 然后基于用户的要求，使用各种工具来分析数据仓库中的数据，并可视化结果，再交给用户做决策 BI系统的功能 不仅支持最新的IT技术，同时也提供打包的应用解决方案（针对企业的立足领域） 前者是日常操作的解决方案，比较固定，可能定期调用，需要的东西不会产生太大的变化 战术性决策支持——影响程度小、执行周期固定 但有些决策是随时间会发生很大的变化的，需要的数据可能也不一样，这就是后者的作用 战略性决策支持——没有套路、提供工具随用随构建 商务智能的构件商务智能的发展商务智能的构件1. BI的构件 传统数据存储：数据库、文件、主页（main frame）、专业相关业务系统、个人计算机（本地） 存的是数据片段（大象的碎片嘿） 结构由每一个业务系统在开发时要解决的问题决定，而非决策人员或BI系统 大噶都是数据源，广义上来说也在BI系统中，狭义上说这块东西本质不可控，BI系统不含数据源 数据仓库 存放信息体 关系模型、多维数据库 也可以拿出一部分作为数据集市，方便管理、提高效率 从1 ==&gt; 2有一个转换（数据到信息的转换） 数据整合ETL 把数据片段整合成信息体 组合得到的信息不一定是正确的，但认为是完整、统一、正确的 相关分析 可视化、脚本…… 提供战略性决策支持 ===&gt; 狭义认为商务智能系统包括：数据仓库和对其中数据进行分析的工具 2. 数据仓库part integrative data 是冗余的数据 当由操作需要比较大的数据量，并且这个操作不会只进行一次，为了提高效率，需要integrative data 数据库是做不到的 3. 数据获取（从1-2的转换需要） 建模工具 不同地方的数据片段可能会对同一样东西进行不同的编码 映射到数据仓库需要建模工具 元数据 ETL 是元数据和建模工具的编码结果 4. 数据与信息 源数据、转换过程——数据 数据仓库——数据&amp;信息 分析工具——信息 5. 数据源 包含内容 操作型数据库 历史数据 包括： 如果是已经用不到的历史数据，会被放到廉价的非在线的存储设备中 当有重要的历史数据需要被查询时，还是可以找到的 也有本操作型/事务型数据库创建之前的历史数据 外部数据（“外部”由企业边界所决定） 没有太大必要性（有必要的话就在操作型数据库中了） 可能是其它企业的数据、中央政策啥的 对于事务性任务来说并不需要，但对于决策分析来说是有必要的，所以也是BI系统的数据源 数据仓库中的信息 一种理解：对数据仓库中的信息进行了分析之后得出的结论又作为数据源放入数据仓库的各个信息体中，使得它们更完整 另一种理解：理论上来说一个企业应该只有一个数据仓库（数据一致性的问题），而外部数据很有可能是一个外部仓库 相关的数据库和数据结构 ===&gt; 数据源存在于不同平台，可以是格式化的，也可以是非格式化的 6. 数据仓库 是BI的重要组成部分和数据基础 工作： ETL： 数据抽取、转换、装载 辨识和主题相关的原始数据 并不是所有采集到的数据都适合作为信息体的一部分（毕竟我的目的是由企业目标决定的，而不是要搞出一个完整的信息体来） 去除分析型环境下无用的数据（高度主观） 数据是否有用和主管分析、上下文、企业关注点有关 开发正确的数据抽取策略 抽取正确和完整的数据 正确的话，比如理解数据源中的编码方式 要达到完整，数据结构要完整，数据源一定要完整，时间上也要完整 将原始数据转换为目标规格 是多到多的映射关系 数据源多个 数据仓库中会有冗余（可能经过了操作 integrative data） 将原始数据加载到预定目标区域 数据目标 数据管理 存储、索引、备份 不仅管理关系数据库中的数据 而且管理数据立方体中的多维数据 数据访问 面向多种商业用户 需要支持多种访问方式以及分析和展现工具 元数据 关于数据的数据，是管理数据仓库的重要数据 描述数据的结构、内容、编码、索引等 种类 关于数据源的元数据 需要正确解析数据源中的数据 关于数据模型的元数据 关于数据仓库映射的元数据 映射成局部的数据、数据集市、数据的概要等 关于数据仓库使用的元数据 比如数据仓库中已经存了一些中间结果可以直接用 元数据管理 7. 分析和展现层 报表和查询 定制报表和查询的能力 OLAP（联机分析处理） 快速的、交互式的相互融合的信息访问方式 可以回答who、what、how、why类的问题 数据库是单维的（列才有意义） 特点 对数据进行多维审视的能力 相关数据已经被整合到一起了 ===&gt; 信息 精密计算能力 时间智能 基本操作 数据统计 将数据中含有的信息概括为统计值 数据挖掘 对数据库（数据仓库）中蕴涵的、未知的、非平凡的、有潜在应用价值的模式（规则）的提取 蕴涵的：非显式的，但数据会对”挖掘“出的决策产生支持 未知的：只针对当前数据集或以后和该数据集有相同规则的其它数据集 非平凡的：无法判定结果的100%对或100%错 不同的数据方法、同一种数据方法不同的参数、同一种数据方法同一个参数运行多次 都有可能得出不同结论 用于发掘数据中隐藏的模式 可以自动化、可以人工 数据上升到信息 商务智能的解决方案商务智能的发展数据仓库从数据库到数据仓库 数据处理分类 操作型处理（增删改查、“随机”发生） 事务处理 对数据库的日常联机访问操作 通常仅仅对一个或一组记录的查询和修改 AKA：联机事务处理（OLTP） 查询简单，执行频率高 关心的是处理的响应时间、数据的安全性和完整性等 分析型处理 AKA：信息型处理 拿到的东西是既成事实，无法修改 主要用于企业管理人员的决策分析，提供辅助决策信息 主观性强，大部分操作事先是未知的 需要对大量事务型数据进行统计、归纳和分析 需要访问大量的历史数据、内外部数据 执行频率不高，对响应时间的要求不高 所面向数据的分类 操作型数据 事务处理所需要的细节性的数据 分析型数据 从操作型数据中加工整理得到 是分析处理所需要的综合性数据 多维的 是只读的 信息系统的发展历史 事务处理系统（TPS）对数据库进行增删改查 管理信息系统（MIS）基于数据库产生的统计报表 统计报表仅基于当前数据库 不可定制 对一些影响比较小的决策起一些作用 主管信息系统（EIS） 跨若干数据库，做全局意义上的决策 需要外部数据 决策支持系统（DSS） 增加了算法 OLAP / DM 基于数据仓库 决策支持系统 数据（数据库、方法库） 算法与模型 展示 事务处理环境和分析处理 在关系数据库中放宽对冗余的限制 数据库以前不允许冗余，因为会有数据一致性问题（all or nothing） 但问题是，所有分析型数据都是操作型数据的冗余嘿 在事务处理环境下建立传统DSS——不适宜 性能特性不同 事务处理 &lt;—&gt; 分析处理 要同时实现可能会非常麻烦（而且不一定能实现 数据集成的问题 DSS需要集成的数据，可能来自多种不同的数据源 事务处理只需要部分细节数据，是分散的 “蜘蛛网”问题 — 每个数据库的数据来源可能错综复杂（互相抄属性值） 数据不一致问题 分散的概念： 对于数据来说，一个信息体的数据项是分散的 对于信息体来说，信息体本身也是分散的 带来的问题 性能很差，可能集成时需要等待很慢的数据库 数据的动态集成问题 人工方式只能做一次集成 — 静态集成 — 难以实现“周期性刷新”（动态集成） — 传统事务处理环境无法实现 历史数据问题 分析处理更看重历史数据，而事务处理一般只需要当前数据 事务处理环境（数据库）下历史数据未能得到充分利用，会被放在别的地方 历史一致性 / 完整性 当前数据库只保有当前最新状态，并不会体现状态的更新和修改过程（因为并不在乎历史数据），比如limit从2500更新到5000，最后拿到历史数据的时候，limit就是5000，不会存在2500 修改主键 or 增加表 使用连接 数据的综合问题 分析处理需要大量的总结性分析型数据 数据库：“数据丰富、信息贫困” 传统事务处理系统不具备综合能力，甚至这种综合还会被认为时一种数据冗余而被限制 数据的访问问题 分析处理的访问以读为主，不需要实时“更新”，但需要周期“刷新” 综上：出现了数据仓库 并非替代数据库 两者目的不同 ​ 数据仓库及其四大特征 定义 是一个面向主题的、集成的、稳定（非易失）的、随时间不断变化的数据集合 用于支持经营管理过程中的决策制定 面向主题（与数据库区别最大的特征） 数据库：面向应用 与数据流程高度相关 逻辑数据不完全分离 和部门、组织紧密相关 信息体不完全 数据仓库：面向主题 抽象 按照某种方式把原来的数据按定义的上下文整合成信息体中的某一个领域 可能不是完整的信息体，但是有意义的 主观有需求，客观有数据 不同主题有重叠内容，但这种重叠的特点是： 逻辑上的而非物理存储上的 部分细节重叠 可以反映不同主题之间直接和间接的关系 每个主题所需数据的物理存储 多维数据库 多维数组 关系数据库 用二维数据模型来存放多维数据 集成 方法： 统一：消除不同数据源之间数据不一致的现象 综合：综合计算 非易失的（稳定的） 数据仓库的数据与操作性数据环境隔离 但数据仓库中的数据也是需要“更新”的 时变的（随时间不断变化） 数据仓库中的数据带有时间属性，包括历史记录和现在的数据都在 以一定时间段为单位进行统一更新 数据仓库的基本结构数据集市于数据仓库数据仓库的应用数据仓库的基本结构数据仓库的关键技术 ETL过程 把来自各种数据源（异构）的数据整合统一后形成一个面向主题的信息体放入数据结构中 数据 ==&gt; 信息 流程： 数据源是异构的：文件、字节流、网页、桌面数据库文件系统等 要从数据源中抽取数据： 必须理解原先数据源中的数据结构、编码等 也要能够理解某一个数据源中的数据与其它数据源中的数据的关系，比如有无重叠、含义是否相同等 解析、校正： 在数据库中，进入数据库前就有各种方法来确保数据正确，那么为什么数据仓库还要校正？ 数据库的数据的校验不能认作靠谱 增补（根据数据项的重要性来选择方法）: 缺失的数据项：大部分的元组都有这个数据项，小部分没有（如果都没有，说明这个数据项就不该存在） 如果有该数据项的元组足够多，那就把那些数据项缺失的元组排除在分析之外 但可能会造成倾斜的数据结果 最坏情况下，完整记录数量会非常少（每个数据项可能都有元组缺失） 以特定标准给元组分类 对于每个类别，以数据项已知的元组来猜测数据项未知的元组 例如： 以每年在某处的平均消费分类，2万以下、2-5万、5万以上 第三类中家庭收入已知的元组大部分家庭年收入在50万以上 合理猜测这一类中家庭收入未知的元组的家庭年收入也在50万以上 匹配： 此时数据结构已经相同，要将属于同一个信息体的数据片段匹配后合并 数据源 可以是递归的 数据的抽取与刷新 刷新的过程是抽取部分的增量 抽取： 是数据进入仓库的入口 屏蔽了底层数据的结构复杂性和物理位置的复杂性 转换和集成的复杂性 操作型环境到数据仓库环境的数据抽取要实现技术上的变化 尽量避免从在线窗口进行数据抽取 在线窗口的数据可能非持久性数据 在线窗口的数据进入数据库时可能已经做过调整，使用更方便 来自操作型环境中的输入关键字在输出到数据仓库之前需要被重建和转换 非关键字要更新格式 存在多个输入记录时，进行记录合并之前要先进行关键字解析（属于同一个信息体的学号、身份证号等要对应起来才能合并） 产生多个输出结果：并发 原来顺序：多个输入 — 1个信息体 — 多个输出（分析数据） 1个信息体可能是瓶颈 ETL工具 数据目标（有效的数据存放位置） 原子层和集成数据 因为计算资源有限，提前算出一些经常使用的数据 ==&gt; 集成数据 数据集市 某个部门或个人分析应用主题用到的数据的子集 提升在特定领域的分析应用效果 操作数据存储ODS 某些部门或个人战术性决策需要实时或准实时的数据 无法在数据仓库中得到直接支持（数据仓库至少以24小时为周期刷新） 在数据仓库以外，持有与数据仓库相同的结构，也是面向主题的 ODS刷新周期较短，刷新频次远高于当前数据仓库 数据仓库面向全局，包含的主题可能有上千个，刷新成本较高，计算瓶颈在数据库 ODS面向明确的、局部的主题，数据量远小于数据仓库 ODS也可以成为数据仓库的数据源（数据结构一样吼） 缓冲区 数据刷新 在原先数据库中确定哪些元组需要更新 确定方式 时间戳：然而问题是大多数数据库中的数据不含有时间属性 DELTA文件： 不信任数据库，应用对数据库进行增删改查时，自己去记录做的操作 效率比较高，不需要对整个数据库对比扫描 但这样的应用很少，理应是数据库完成的任务 日志文件 由数据库自己生成 建立映像文件 做快照（copy） 数据周期（在数据仓库中）：不低于24小时 数据量不以数据周期定义 有些数据库里的数据可能会被撤销，不需要进入数据仓库 刷新会占用软硬件资源和网络传输资源 数据颠簸性 个人理解：数据库中的数据在固定的一段时间内修改得会比较多，这段时间后数据就基本稳定下来了（这个时间一般为24小时） 数据仓库中的数据以及数据管理 数据： 包括细节性业务数据和分析型数据 管理： 借助数据库技术 具体： 原子层（核心、基础）：最详细、数据量最大、存放最多细节 其它数据结构借助原子层来计算分析数据，目的是加速 特点： 保持历史完整性（即记录有意义的历史数据，意义来自主管需求） 构建是迭代的（非一蹴而就） 数据结构是迭代的 随主观 &amp; 客观变化而修改 即使在数据仓库相对稳定的运作过程中，数据内容也在迭代 数据结构面向企业 可以是集成（非原始数据）的 原本最详细是指与数据源中的数据粒度保持一致 若存储资源不足，并且也没有相应需求，则原子层中就存集成数据（在数据源基础上集成 是静态的 一次ETL完毕到下一次ETL开始，原子层是一个静态的镜像，访问多次都是一样的 即一段时间内是静态的 数据库非静态 粒度 对数据仓库中数据的综合程度的一个度量 影响数据仓库中数据量 影响数据仓库能够回答询问的种类 样本数据库（抽样）： 数据仓库的子集，数据量更小 不能用于一般性的分析目的，只能用于统计分析 粒度可以根据采样率高低来划分 多重粒度 分析应用中主流的查询要求是比较综合的，但也会有很小一部分的查询是很细节的 这个细节查询也需要满足 真实数据仓库中：多重粒度 原子层中按最细粒度给出完整数据 从原子层中计算、聚合数据得到高粒度数据以满足综合查询 不同粒度用不同设备存储 多维度、多层次：数据仓库中 维度是观察数据对象的角度 层次是数据对象的综合程度 一个维度中，例如时间维度可以有天、周、月等 每一个对应维度都可以泳有多个层次 数据仓库的数据组织形式 简单堆积文件 轮转综合文件 针对综合层次 在简单堆积之上继续操作 第一层一次写满之后进行聚合放到第二层 第二层和第三层也是一样 简化直接文件 数据集市与数据仓库1. 建立数据集市的原因 数据仓库是全局的，数据量很大，对于一个部门来说，不需要这么多数据就已经可以做出决策了 数据集市（部门数据仓库）是反映子主题的数据仓库的真子集，与部门的分析领域相关 ==数据结构可以和数据仓库不一样== 然鹅理论上来讲是和数据仓库严格对应的，在ETL时就会被写进去 ===&gt; 提高效率与性能 ===&gt; 提高数据安全性（权限控制） 操作型数据库 vs. 数据集市 业务与分析的区别 没有对应关系 数据集市的数据不一定是来源于本部门 联机分析处理OLAP1. OLAP 从OLTP到OLAP OLTP：联机事务处理 OLAP：联机分析处理 OLAP： 专门的数据综合引擎（OLTP【细节】中没有） 公共应用逻辑：数据散布在不同数据源，针对这些数据进行整合的业务逻辑 在短时间内响应非数据处理专业人员的复杂查询要求 要求在线 ===&gt; 短时间 &amp; 在线是无法在OLTP中实现的 针对特定问题的联机数据访问和分析 对信息的很多种可能的观察形式（多维度多层次）进行存取 OLAP vs. OLTP 2. OLAP的特征及衡量标准 Codd关于OLAP的评价准则 OLAP必须提供多维概念试图 信息体是多维的，上下文不止一个 透明性准则 OLAP在体系结构中的位置对用户是透明的 服务器在哪、计算在哪、数据结构如何等都是对用户透明 OLAP的数据源对用户透明 存取能力准则 底层异质数据存储进行多维展现 OLAP存取应该用统一的相同的界面 稳定的报表功能 数据的维数和综合层次增加时，提供报表能力和响应速度不能有明显的减慢 C/S体系结构 现在不一定了，可以是P2P 维的同等性原则 当前信息体在所有维度上能完成的操作应该是一样的 例如普通三维 + 第四维时间，在x轴上可以向后平移，但在时间轴上不可，就不满足同等性 动态的稀疏矩阵处理准则 为什么会存在稀疏问题？ 同等数据量下维度的增加（维度的增加造成可能的取值空间增大） 多用户支持能力准则 并发访问 分时 问题： OLAP往往不止由数据仓库（不要求在线）支撑，还会有其它的支撑 非受限的跨维操作 比如年月日这种固有的层次关系 直观的数据操作 灵活的报表生成 不受限维度和聚集层次 度量值 分析型处理中，关系和分析的对象 数据是衡量的标准 维 观察度量值的角度 度量值关联到其它数据构成维度 层 反映对度量值的观察深度 粒度 按日、周、月、年，都是不同层次 划分方式 OLAP天然支持 指定 细粒度数据不一定能算出高粒度数据 如周数据可能算不出月数据（周可能跨月） 可以主观指定 时间维、地域维、商品维 层次数量和基数成反比 维成员 维的一个取值 可以是层次，也可以是层次组合 多维数组 维度(n) + 度量值(k)、 为每一个维度指定一个维成员（一个集合）来拿取当前度量值 度量值不会被拿出来直接解释 要给定当前维中的维成员 数据单元（单元格） 存放多维数据确定的度量值 多维数组和联机分析处理 可能性很多，需要提升访问性能 3. OLAP的几个基本概念4. OLAP中的数据构造方式 ROLAP（关系数据库管理系统） 把多维数组用关系型数据库管理 多维查询首先要翻译成数据库语言（SQL），期待得到一个结果集 MOLAP 多维数据库管理系统，基本数据模型就是多维数组 下标访问 多维数据引擎直接访问 ===&gt; 更快 HOLAP（混合） 上两种各有利弊 适合放在R的放R，适合放M的放M 反复应用综合数据放在多维数据库（作为加速机制）中 减小数据量 类比缓存（调度、命中） OLAP需要解决的问题 提高数据访问效率 ETL &amp; 查询 &amp; 更新效率 5. OLAP的基本数据模型 更关注OLAP数据访问的效率 数据存放 结合MOLAP和ROLAP MOLAP MDDB vs. RDBMS MDDB： Data File适合放稠密数据，效率会很高（算偏移，直接查 高层次数据会更稠密 高层次数据增加维度有低层次数据支撑 给某个维度插入维成员麻烦（时间复杂度高） 无论数据有无定义，在多维数据模型中都有这个数据的位置 RDBMS： 二维，有定义才会存在于二维表中 两类数据分成两个表存 存放有定义的度量值的事实表 维度使得作为数据的度量值上升为信息 度量值若为向量，则他包含若干列 维度用外关键字来加以涵盖 存放维属性及其取值的维度表 查询： 以维度表作为入口做二维查询 查询得到每一个维度的结果集 把得到的所有结果集进行自然连接后查询事实表 得到事实表的子集（度量值），进行聚合 ===&gt; 效率低于MDDB，但解决了稀疏矩阵的问题 增加维成员不影响原数据结构 增加维度会导致维度表和事实表属性（外关键字）的增加 ===&gt; 应对变化更灵活 星型模型 多维表结构 事实表 x 1 维表 x n 可以转化为一系列二维表 （纸质） 6. 数据立方体（……） 在数据立方体中找到一个合适的维度（子集）与层次 维度的粒度也可自己决定 对数据立方体进行处理 不进行物化 只保留基子方体，粒度最细，需要其它视图时就实时计算 全物化 后台只有多维模型，单OLAP，全算 混合OLAP，算的结果放在数据库或星型模型中 计算、存放资源浪费 部分物化 冰山方体 挑选依据： 整个数据立方体中进行物化需要的资源是多少 不怎么占用资源，实时在线算也可，就不一定需要物化 物化带来的效果 物化也可以有层级 0-D可以基于2-D而不一定基于4-D（方体格中） 7. 多维数据分析 定义：对以多维形式组织起来的数据进行一系列操作后分析 操作： 切片 切掉不关心的数据 切块 旋转 上钻 关注对象仍是本人，但层次上升 细节信息被抹去，信息被概括 视图–&gt;另一个视图 子方—&gt;另一个子方 3D — 2D是一种上钻（某个维度被上升为All 下钻 特例：引入全新维度 维度从ALL下降到具体 ===&gt; 上钻下钻最消耗资源（要考虑支撑信息能否支持实时在线性 ===&gt; 上钻下钻可以实现是因为方体格中有详细信息 drill across 上面讨论的都是单一的数据类型，但维度可以连接事实表，有几个事实表可能就有几个数据立方体 联合分析多个多维模型中的多个度量值 drill through 基本子方不会放在OLAP服务器上 代价高（数据仓库原子层中就有）、没必要 要用到OLAP服务器上没有的详细数据了呢？drill through 数据仓库的设计1. 由来 vs. 数据库 有一致 有不一致 最大的差异在于构思（概念模型设计） 数据库中：数据流分析 数据仓库中：无数据流分析，按某种主题构思星型模型或雪花模型 数据仓库没有需求驱动 它要支撑所有的分析应用，可能部分分析应用的需求是明确的，但没有评价标准 建造数据仓库的主要两部分 与操作型系统接口（ETL）的设计 数据仓库本身的设计 2. SDLC vs. CLDS SDLC: 需求和数据库中的数据是对应的（需求驱动 数据库被交给应用编程人员时，数据库就算是交付完毕（有错再说 此时数据库为空 数据库优先于应用编程存在 CLDS： 有一些客观存在的数据源，但是没有需求 数据源限定了数据项，可以猜测有什么样的需要 数据仓库被构造出来的标志： 完成第一次ETL，仓库中有数据了 DSS应用编程 可能基于猜测的需求和分析人员的明确/不明确的需求 系统测试： 是否缺失需要的数据 结果是否满意 接下来就可以重新理解需求了 ==需求在后== 3. 设计原则 面向主题 vs. 数据库 建立目的 需要执行的分析操作 数据驱动原则 预先定义数据模型 可以和具体实现毫无关联 原型法设计原则 4. 过程/数据模型与设计环境 基于过程的模型 操作型环境 数据仓库中没有过程 数据模型 操作型、分析型环境都可 企业级数据模型 数据模型的性质 稳定性：较少变更的数据放在快速设备上？经常更改的放在慢速上？？？ 会影响到刷新频率 数据模型与迭代开发 迭代开发 新的数据源（客观变化） 数据模型指示迭代方向 预测数据仓库的主题，将主题划分来决定迭代 设计主题的边界（公共维度 ===&gt; 雪花到星座、雪花到雪暴） 不存在没有关联（通过公共维度能够访问到两个主题）的主题 如果迭代1 2 开发的主题1 2 发现没有关联，可以把迭代9的内容提前，因为主题9连接起了1和2 如果没有上述的调整（监管机构和方式方法），瞎比比挑一个顺序开发，会导致 有重叠（浪费） 不一致和冲突 ===&gt; 另一个数据源 再添加主题时，无法将其设计得与现有的乱糟糟的数据模型兼容 不考虑： 各次迭代的开发团队 团队是否并行 数据仓库设计的三级数据模型 概念模型 //高级模型 E-R 逻辑模型 //中极模型 关系模型（数据库中的二维表） 物理模型 //低级模型 逻辑模型在数据仓库中的实现 数据仓库的设计步骤 系统规划： 明确主题 迭代过程所需要的数据模型 从无到有： 这些主题可能只有一个名称（不需要明确细节 主题可能会交给分析人员，由其增删改，最后汇集到数据仓库的设计人员 设计人员提出公共维度 主题 + 公共维度 ===&gt; 数据模型的最小集合 必须要回答的问题（原型设计法）： 有哪些主题 接口是什么 技术准备 具体的技术要求和物理实现环境 迭代“明确主题”part 数据仓库的设计 生成和运维 概念模型设计 一个分析域中的主题放在一次迭代中 概念模型设计 确定系统边界 确定主要的主题及内容 星型、雪花（广义上来说仍然是E-R OLAP等分析应用的设计 逻辑模型设计 将E-R图转成关系数据库的二维数据表 定义数据源和数据抽取规则 数据库中没有 考虑一些问题 粒度划分 详细数据 || 轻度总结 || 高度总结 没有非常明确的、排他的定义，没有定量差异 不同粒度的表是不兼容的 面向的是事实表 数据分割策略 类似于数据库中的分片 分割谁？按什么分割？ 分割事实表 通常采用时间属性作为数据分割的依据 时间几乎是所有事实表都会有的一个外键 可以预估一张子表的规模、大小 定义数据来源及抽取规则 物理模型设计 优化 合并表 减少表的连接（消耗很大）次数 代价：浪费空间 数据库中要么只有分开的表，要么只有合并表（不允许冗余 数据库中所有表的大小是“一样的” / “等价的” 数据仓库中的访问模式并不固定，合并表可能只能满足一小部分的访问 数据仓库中有两种表：维表、事实表（事实表肯定大于维表 数据序列 还是固定访问某些表，但是并不需要所有的属性，可能只是固定的几张表里固定的几个属性 合并表开销太大而且并没有提高性能 把这些固定的属性挑出来放进一个数据结构中（并不合乎逻辑 但注意数据库不能有冗余吼 引入冗余（狭义上的） 表的物理分割（区分于逻辑模型设计中的分割（切元组、切事实表 纵切：对于一张表格中包含的属性进行切分 访问频率 更新频率 决定资源分配：给经常访问但不常更改的快速访问设备，给不常访问常常更新的数据较慢的设备 拆维表，不拆事实表 ===&gt; 从企业级的数据模型中来，或者从log中分析 生成导出数据 给一个没提到的数据物化以后存放的位置？？ 建立广义索引 记录数据仓库中与“最”有关的数据 数据库中不存在（这是个冗余数据 顶不住啊，索引次数太多辽 在每次ETL时进行刷新 如果不需要实时刷新 小程序 需要实时刷新 限制广义索引的范围 业务领域、管理活动中都有 数据仓库生成 建立数据模式 编制数据抽取程序（ETL） 数据加载 数据仓库的使用与维护 6. 数据仓库的生命周期 数据模型分析 粒度分析 逻辑模型分析 数据量的预估 本来在第二个模型才要考虑的，被提前 技术评估 技术环境准备 主题域分析 数据仓库设计 源系统分析 程序说明 编程 ===&gt; 8 9 == ETL 组织构建与主题的明确多维建模1. 多维建模初步 事实表 维度建模的核心 一个事实表对应一个或一组度量值 表中一行对应一个度量值 每一行的粒度应该相同 粒度划分模型 事实表中的度量值 基数很大 基数往往和提供的信息量大小成正比 非文本、枚举、bool等 最常用：数值类型 可以连续取值 三种类型的度量值 可加 可沿某些维度加 不可加（一般不会出现这样的度量值 事实表中的关键字 事实表中有上下文 不同于数据库，数据库的上下文是由应用来定义的而不是由表的内容来定义的 数据仓库中，是通过维度表中的维成员连接事实表，拿取度量值进行聚集得到结果，所以没有必要按照独立的关键字对当前事实表进行检索 每张事实表有&gt;=2个外关键字，用于连接到维表 所有外关键字组合构成主关键字 维度表 事实表的入口，是提供给用户的数据仓库的接口 列用于区分维成员 越多的属性（列）可以越精确地区分维成员 因此维度表的定义通常包括尽可能多的列 维度属性 通常是文本数据或离散数据 使用区间 少使用编码属性（直接用文本描述 数据库中常用编码加速 数据仓库不需要快 问题：当前分析人员能否正确还原编码？（歧义 面向的人员不同（数据库的使用人员是程序员嘿 vs. 度量值属性 事实与维度的融合 2. 多维建模案例 维度建模的设计过程 选取要建模的（分析型）业务处理过程 从零开始：大部分的“需要”是“猜测” 迭代过程：斟酌之前的“需要” 选择事实表中的维度 事实表中的维度表 事实表专有维表，是当前事实表的特定维度，不与其它事实表有关联 公共维表，在多个事实表中进行共享（在进行维度建模前就已经建立（总线（不隶属于维度建模过程，只需要决定要引入哪些 与私有维度无关 2.1 零售营销 需求分析 数据驱动 面向主题 主题不需要很详细，后续会细化修改 维度建模的设计过程 选定维度 日期、商场、产品是从总线中挑选出来的 促销维度是新建的 确定事实 度量值 直接度量值：可以直接从数据源中拿到或通过计算得出 导出型度量值（如毛利润金额 来源于其它度量值，可以放在事实表中，也可以不放，需要用到时现场计算 看存储开销 vs. 计算时间（多长时间被访问一次） 如果不具备可加性，就不需要放置在事实表中 维度设计 前面就应该做好 多级体系划分属性，多对一对应关系，数据量越来越小 分析的角度是组合维度而并非互斥（独立维度） 如果真的是互斥角度，则放在一个维表里会造成空间浪费和分析困难，应该独立出每个维度来，但是没有了组合的概念 会给事实表引入更多的外键（事实表的元组肥肠多，相比之下多出来的空间比我之前放在一起浪费的维度多多了×） 数据仓库中维度不能为null为空 null || 空无法进行连接 使用特殊行来表示null ===&gt; 准确的外关键字 所有用这个特殊外关键字来连接到事实表的都认为该维度为空 存在问题：只存放关心的东西 事实表中只有进行促销并且卖出去的商品，那进行促销但没卖出去的呢？（即本事实表关心的是卖出去的促销商品，以此分析促销对于商品销售的影响 在数据库中没有问题，因为这个说明数据库就是用来记录卖出去的促销商品的 但数据仓库应该支持各种各样的分析需求 需要一个非事实型事实表——促销记录 没有分析价值——没有度量值 需要其它事实表联合分析 为什么不直接放进事实表？ 粒度不同 非事实型事实表中：只要有一个促销组合（组合是上面的概念），就会加入 退化维度 库存事务 库存快照无法提供的分析（为什么需要库存事务）： 无法区分一天之内入库又出库的情况和一直没有入库的情况 无法知道入库的具体情况 分多少次入库 何时入库 ===&gt; 可能会导致运输成本的变动，这是需要分析的点 ===&gt; 当前周期快照粒度过大，无法进行细节性分析 ===&gt; 需要事务性粒度的数据 库存事务类型维度 库存事务的私有维度 库存事务类型组： 按各种标准拆分事务 但数据粒度过细，数据量会增大，要回答一些简单的分析问题时不如库存快照 库存快照和库存事务结合使用（如果两种分析都需要） 库存累积快照 入口事件发生就增加一个元组，所有度量值设为不可用 一个元组中并非所有事件都会发生，如果记录终止在了某个事件上，那么这个事件之后的事件都是“永不发生” 改善库存事务查询普通分析的要求数据时效率过低问题（表的连接过多） 有效加速对于重要采购记录的访问速率 需要的存储空间很大 但进入这个累积快照的数据是有门槛的（重要数据）（大白菜咋了大白菜不好吃啊） 何时认为快照已经被完全构造出来了？ 没有任何一个FK指向“尚未发生” 所有日期类型的FK指向固定日期或“永不发生” 主题的集成 主体之间的维度共享 连线关系为引用关系 ===&gt; 总线结构 数据仓库的总线 总线结构独立于多维建模，事先就被创建好 数据仓库总线矩阵 行：若干个主题或主题细分 列：公共维度 可以确定维度和哪些主题相关，设计该维度时就可以更全面，而不是多次迭代修改数据结构 尽管主题的详细信息都还未知 主题分多次迭代 相关的主题放在一次迭代中 ===&gt; 重叠的公共维度较多 可以根据一次迭代中的主题来决定哪些维度先设计","link":"/2021/12/21/BI/"},{"title":"商业模式类型","text":"讨论建筑风格的意义在于捕获建筑设计的理念，将其作为典型的、可重复使用的描述 分拆商业模式 企业内部的三种活动驱动因素不同，彼此之间冲突，企业内部消长 通过分拆使其各自独立 背景 包含基础设施管理、产品创新以及客户关系管理于一体的模式 挑战 成本过高 若干相互冲突的组织文化共存于同一实体中，产生不良的消长 解决方案：将企业解绑，分为三块独立但互补的模式 基础设施管理（经济） 新产品开发（竞争） 客户关系管理（文化） 理论依据 信息技术以及管理工具的改善，使得不同企业独立但相互协作的商业模式获得更低的运营成本，从而消除了不良的消长 案例 私人银行 移动通信运营商 可口可乐 开放的商业模式 企业的研发的流程对外敞开 由外到内：将外部的理念、技术或知识产权引入内部 由内到外：将内部的知识产权或技术，特别是闲置资产向外出售 背景 研发资源和关键活动都聚焦在企业内部 理念全数来自“内部” 成果全数用于“内部” 挑战 研发活动成本高，且效率低 解决方案 内部研发资源和活动因得到外部合作者的使用而被激活 内部研发成果转化为价值主张并提供给感兴趣的客户群体 理论依据 从外部渠道获得研发成果可能成本更低，并缩短产品上市的时间。将未利用的创新成果向外部销售，从而可能带来更多的收益 案例 宝洁 多边平台商业模式 多边平台将两个或更多独立但相互依存的客户群体进行连接 平台对于其中某一客户群体的价值来自于其他群体的存在 平台通过促进不同群体之间的互动而创造价值 一个多边平台价值的提升在于它所吸引的用户数量的增加 背景 一个价值主张只针对一个客户群体 挑战 企业无法获得潜在的新客户，这些新客户对于公司的既有客户群体十分感兴趣 例如，游戏开发商希望能够得到游戏机玩家 解决方案 提出新的价值主张，使得一家企业的既有客户群体让人“够得到” 例如，游戏机生产商为自己的软件开发商提供与游戏机用户的沟通渠道 理论依据 作为媒介以平台方式沟通两个或多个客户群体，为原有的商业模式增加了收益来源 案例 谷歌 任天堂、索尼、微软的电子游戏机 苹果公司iPod、iTunes以及iPhone 免费的商业模式 至少有一个关键的客户群体可以持续免费地享受服务 通过其他方面补贴免费产品 可行方式 基于广告 免费增值 诱饵&amp;陷阱 背景 高价值、高成本的价值主张，只面向付费客户提供 挑战 高价格让客户望而却步 解决方案 面对产生不同收益流的不同客户群体，提供不同的价值主张，其中一种是免费模式（或低成本模式） 理论依据 用付费客户群体来补贴免费客户群体，从而吸引最大数量的用户 案例 广告和报纸 开放源码 红帽公司 长尾商业模式 提供相当多种类的小众产品，每类卖出量相对很少，但汇总的销售收入可以与传统模式销售媲美 背景 价值主张只针对最能产生利润的客户 生产工具的普及：文字发布、视频录制、生产与设计外包 销售渠道的普及：互联网 连接供需双方的搜寻成本降低：搜索、推荐、用户评级、社区 挑战 针对利润较小的群体设置不同的价值主张，成本过高 解决方案 这种新的或者说附加的价值主张针对的是之前看来利润较小的那一大部分群体，小众客户群体总体而言是盈利的 理论依据 信息技术以及运营管理方法的改善使得定制化的价值主张得以面向大量的新客户，并且以低成本实现 案例 出版行业 乐高 netflix","link":"/2021/10/24/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B/"},{"title":"商业模式画布","text":"商业模式定义一个商业模式描述的是一个组织创造、传递以及获得价值的基本原理，其本质在于价值的流动 围绕商业模式的基本活动 画布：基本模型与工具 类型：利用画布分析常见的商业模式 设计：商业模式的构建手段 战略：商业模式的环境、评估、规划、管理 流程：完整的商业模式设计流程 商业模式画布情感端客户细分Customer Segments企业想要获得的和期望服务的不同的目标人群与机构 细分条件 需求催生新供给 需要新分销渠道和客户关系模型 产生的利润率不同 愿意为某方面的特殊改进买单 划分方式举例 大众市场：强业务特征 小众市场：其价值主张、分销渠道、客户关系聚焦于一个庞大的、有着广泛的相似需求和问题的客户群 求同存异的客户群体：某业务下基于客户共性的细分 多元化客户群体：服务于两个需求和问题迥异的客户群体 多边平台/市场：服务于两个或 多个相互独立的客户群体 价值主张Value Proposition为客户群体提供能为其创造价值的产品与服务，价值主张是客户选择一家公司而放弃另一家的原因 有益于价值创造的因素 创新：价值主张满足客户之前未曾察觉的新需求 性能：改进产品或服务的性能 定制：针对某些客户或客户群体的某项需求提供定制的产品或服务 保姆式/一站式服务：简单地帮客户完成任务 设计 品牌/地位：客户可以简单地通过使用和展示某一品牌而获得价值 价格：以更低的价格提供相同的价值是满足价格敏感型客户群体的需求的普遍方式 缩减成本：帮助客户节约成本是创造价值的重要方式 风险控制：为客户购买的产品或服务降低风险 可获得性：帮助客户获得之前他们无法获得的产品和服务 便利性/实用性：让产品使用起来更方便或操作起来更简单 渠道通路CHannels一家企业如何同它的客户群体达成沟通并建立联系，以向对方传递自己的价值主张 作用 了解产品与服务 评估价值主张 购买产品与服务 传递价值主张 提供售后支持 五个阶段 知名度：我们如何扩大公司产品和服务的知名度？ 评价：我们如何帮助客户评价我们的价值主张？ 购买：客户如何能够购买到我们的某项产品和服务？ 传递：我们如何向客户传递我们的价值主张？ 售后：我们如何向客户提供售后支持？ 客户关系Customer Relationship一家企业针对某一个客户群体建立的客户关系的类型 动机 开发新客户 留住原客户 增加销售量或单价 类型 私人服务：基于人际互动。客户可以与客户代表进行交流并在销售过程中以及购买完成之后获得相应的帮助 例：商场导购 专属私人服务：要求为每一个客户指定一个固定的客户经理 例：私人银行服务 自助服务：企业无需直接维护与客户的关系，只需为客户提供一切自助服务所需要的渠道 例：ATM 自动化服务：将相对复杂的客户自助服务形式与自动化流程相结合 例：各类平台推荐系统 社区：企业使用用户社区来融入客户以预判市场未来发展的方向，帮助更好地了解客户 例：小红书 客户共同创造：超越传统的买卖关系，与客户合作共同创造价值 例：B站 收入来源Revenue Streams企业从每一个客户群体获得的先进收益 方式 资产销售：实物产品所有权的出售 例：亚马逊 使用费：对某种具体服务的使用 例：话费 会员费：向客户销售某项服务持续的使用权限 例：健身卡 租赁：将某一特定资产在某一个时期专门供给某人使用并收取一定费用 例：共享单车 许可使用费：向用户授予某种受保护知识产权的使用权，并向其收取许可使用费 例：专利授权 经纪人佣金：向双方或多方提供的中介服务 例；房产中介佣金 广告费：为某种产品、服务或品牌做广告的费用 理性端核心资源Key Resources保证商业模式顺利运行所需的最重要的资产 类型 实物资源 例：生产设备、房屋、车辆、机器 知识性资源 例：品牌、专营权、专利权、版权 人力资源 对于创新性和知识密集产业最重要 金融资源 例：车贷 关键业务Key Activities保证商业模式顺利运行所需做的最重要的事情，于价值主张强相关，价值主张的具象化 类型 生产：设计、制造以及分销产品 例：制造企业 解决方案：包括知识管理和持续的培训 例：咨询公司 平台/网络：涉及平台管理、新服务的启动以及平台的升级 例：eBay、visa 重要合作Key Partnership保证一个商业模式顺利运行所需的供应商和合作伙伴网络 类型 非竞争者之间的战略联盟 竞争者之间的战略合作 新业务的合资公司 稳定供应关系的供应商和采购商 合作动机 优化与规模效应：降低成本，外包或共享基础设施 特殊资源及活动的获得：高技术产品、销售团队、特许商品 降低风险和不确定性 成本结构Cost Structure运营一个商业模式所发生的全部成本 导向 成本导向：成本最小化，创造并维持极尽精简的成本结构 价值导向：高端的价值主张与高度的个性化服务 特点 固定成本：不因产品及服务的产量而改变的成本 例：管理员工工资、租金、生产设备 可变成本：随着产品及服务的产量而同比例变化的成本 例：广告推广费、水电、原材料消耗 规模经济：企业的产出扩大，会带来成本优势 例：大宗采购，大规模生产摊薄的固定成本 范围经济：企业的经营范围扩大，会带来成本优势 例：同一个营销活动或分销渠道上可以供多个产品使用 画布模块之间的联系 纵向联系 客户关系 -&gt; 渠道通路 -&gt;收入来源 关键业务 -&gt; 关键资源 -&gt;成本支出 跨越的联系 客户关系选择与成本支出导向（定制化、个人化 – 价值导向 VS 自动化、大众化 – 成本导向） 建设渠道通路所需的核心资源与重要合作 细分的客户群体是否认同上游的重要合作方与引入的外部关键资源？ 联系的联系 平台：多个“价值主张-客户细分”对的组合才能构成完整的收入来源","link":"/2021/10/07/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E7%94%BB%E5%B8%83/"},{"title":"商业模式设计","text":"工具、方法、思维 设计的三个相互重叠的空间：灵感、构思、实施 客户洞察 客户视角是商业模式的指导性原则，客户的观点决定了我们选择怎样的价值主张、渠道、客户关系和收益来源 客户洞察的难点 透彻理解客户（ “问题背后的问题” ）；需要人类学、社会学理论（笼统的人），以及与实地调研（具体的人）结合； 清楚了解企业当前关注哪些客户（的需要），忽略哪些客户（的需要）— 需要有所取舍 辅助工具：移情图 罗列所有客户群体，挑选三个最有希望的，选择一个作为分析对象 构成 看：描述该客户在她所处的环境中所看到的东西（她眼中的产品、周边的人与朋友、能接触到的同类产品、遇到的困难） 听：描述环境如何影响到这个客户（她朋友说了什么、配偶说了什么、哪些人以怎样的方式真正影响到她、有影响力的媒体渠道） 说&amp;做：想象客户可能的言辞，或公共场合的行为（持有的态度、对他人的言论、要重视真实想法与外部言论之间可能的矛盾） 想&amp;感受：尝试勾勒你的客户思维的过程（哪些事情是真正重要的、她的情绪与可能的触动、夜不能寐的事、梦想与渴望） 痛点：已遭受的挫折、正遇到的阻碍、怕承担的风险 收益：预期成就、成功衡量标准、实现目标所采用的策略 场景 两种场景 不同的客户结构：结合客户洞察描绘出独特、具体的图景 未来可能的竞争环境；想想未来可能的具体细节，品味特定条件下商业模式如何演进 为一个故事设计并补充场景 了解与评估 购买与传递 交互 售后 评价与复购 构思 概念：一个能够产生大量商业模式创意，并成功识别出其中最佳创意的流程 两个步骤：生成大量创意 -&gt; 对创意进行整合并挑选 提出新创意的两个出发点 从画布中寻找创新的焦点 资源驱动 创新来源于组织现有的基础设施或合作伙伴资源 例：亚马逊云计算服务 供给驱动 创造全新的价值主张，并影响到其它模块 例：墨西哥水泥厂商Cemex承诺4小时内将水泥送到 客户驱动 基于客户需求、可获得性或便利性的提升，并影响其他模块 例：23andMe为个人客户提供DNA测试服务 财务驱动 由新收益来源、定价机制或者被缩减的成本驱动的创新 例：施乐公司提供复印机租赁 多点驱动 多焦点驱动的创新，并对其它模块产生深远影响 例：Hilti向客户出租建筑工具 不断提出“如果…会怎样”的问题 用此类问题打破在设计过程中遇到的现有商业模式的束缚，并使更多新奇的、难以执行的主张闯入我们的思维 例：“如果学生因为疫情无法到校又要求不停课怎么办？” 流程 团队组建 关键问题：为了产生新颖的商业模式创意，我们的团队是否足够多样化？ 组建正确的团队对产生有效的新商业模式创意至关重要 钻研 关键问题：在生成商业模式创意之前，我们必须钻研哪些知识？ 钻研阶段包括总体研究、研究客户与潜在客户、详细调查新技术、评估现有商业模式 开拓 关键问题：我们能针对商业模式的每个模块做哪些创新？ 从九大模块任意一点出发作为创新起点；数量是关键；重在创意，避免过早评论价值 甄选标准 关键问题：我们为商业模式创意排序最重要的标准是什么？ 需要涵盖：预期实施时间、潜在收入、可能的客户阻力、对竞争优势的影响 构建模型 关键问题：对于每一个进入短名单的创意，它完整的商业模式会是怎样的？ 确立标准后，团队从创意中整理一个最优短名单，由此构建3-5个创新的商业模式，再利用画布进行勾勒和讨论 头脑风暴 规则 保持聚焦：精确表达当前问题、始终与客户需求有关、不要跑题太远、将讨论拉回到开始问题 执行规则：坚决执行开始时的规则：“不过早下结论”、“每次一人讲“、”追求数量”、“可视化”、“疯狂创意” 视觉化思考：将创意写或者画在每个人都能看到的地方：便利贴+黑板/墙 准备：为一次头脑风暴所准备的钻研：技术研讨、实地考察、客户讨论等各种形式 无声的头脑风暴、笨牛训练 视觉化思考 价值 抽象的东西具体化、复杂的概念简单化 视觉化能够一目了然的刻画商业模式的主旨，并具象化其中的隐含假设 视觉化能够使商业模式变的明确，为团队讨论提供一些概念性的锚点，使讨论从抽象思维落实到具体、形象的东西 视觉化既能找出已有模式中的逻辑缺陷，又能在设计全新模式时更容易地添加、删除和移动相关的图片化概念 两项技术 如何使用便利贴 + 如何将草图与商业模式画布结合 四个流程 理解、对话、探索、沟通 实现 便利贴 + 绘画 作用 理解商业模式的本质 提升对话效率 探索创意 提升沟通 如何讲述视觉化故事 绘制商业模式 用简单的文字填充各个商业模式模块，一个模块只用一张便利贴 用图形描绘每个商业模式元素 每次取下一张便利贴，再用图形去取代文字想表达的内容，图形保持简单 设计故事主线 决定讲故事的时候先贴哪张便利贴；可以尝试不同的主线与起点，只要能支撑故事 讲述故事 根据便利贴的顺序与贴图的内容逐一讲述你的商业模式 模型构建 这里的“模型”：用于讨论、探究或概念验证的工具，目标是探索未来潜在的商业模式（不等于软工领域的模型或原型），可以是草图、画布或财务报表 价值 与视觉化思考一样，模型构建可以使抽象的概念具体化，帮助探索新的创意 模型构建有助于实际商业模式的探索 建模-（疑问点明确化、视觉化）-添加、删除或修改元素-观察结果 在不同规模（抽象层面）的模型上进行互动 有助于获得突破性的商业模式，同时能够有效控制细节 设计态度：专注探索，全面考虑，快速放弃，选出值得优化的想法，接受不确定性 控制规模：通过绘制很多（粗略的和细致的）模型来代表各种战略选择，再通过对每个模型添加和移除元素的方式来探索新想法 随手素描：勾勒和推销一个粗略的主意（含价值主张和主要收益来源） 勾勒想法，含价值主张和主要收益来源 精心描绘的画布：探索实现该创意所需的因素 完整画布，商业逻辑思考，市场潜力预估、理解模块之间联系、“事实查证” 商业案例：检查该创意的可存活度 全面画布，关键输入、核算成本与收入、估算利润潜力、模拟财务场景 实地验证：调查客户的可接受度和可行性 准备合情合理的商业案例，站在客户角度进行实地验证，验证价值主张、渠道、定价机制等实际市场中的元素 模型，不求精细，胜在快速 早期的模型应该是快速的、粗糙的、便宜的 适可而止：模型的目的是赋予想法具体的外形，了解该想法的长处和弱点，从而为更详细、更精密的下一代模型寻找方向（最终转向具体设计） 讲故事 价值 故事是一个理想的热身工具，为深度讨论商业模式与其内在逻辑做好准备 将故事与画布结合，利用叙事性克服听众对不熟悉模式的抵触，放下对陌生事物的怀疑 目的 介绍新想法：尝试融入组织战略 向投资人推销：争取外部资源（是什么，为谁服务，如何获得收益） 吸引员工（成员）：抓住组员的注意力和好奇心，为下一步探讨准备 让未来触手可及：激发创意、辩证变革 开头方式 公司视角 客户视角 方法 图片和旁白 视频 角色扮演 文字和图片 连环图画","link":"/2021/11/07/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1/"},{"title":"商业模式评估","text":"商业模式环境评估市场影响力 市场问题：从客户和供给的角度识别出驱动和改变你的市场的关键问题 影响客户环境的关键问题有哪些？ 哪些改变正在发生？ 市场将走向何处？ 市场分类：识别主要的市场群体，描述他们的兴趣点，尝试发现新的群体 哪些是最重要的客户群体？ 哪个群体的增长潜力最大？ 哪些群体在缩小？ 哪些边缘群体值得留意？ 需求和诉求：列举市场需求并分析这些需求被满足的程度 客户需要什么？ 没有被满足的客户需求里哪个最值得关注？ 客户真正想要搞定什么？ 哪些需求在增加？ 哪些需求在减少？ 切换成本：客户一旦转投竞争对手，哪些方面需要改变 哪些东西将客户捆绑在一家供应商和它的服务上？ 哪些切换成本组织客户转投竞争对手？ 客户容易找到并采购类似的服务吗？ 品牌有多重要？ 收入吸引力 识别与收入吸引力和定价能力相关的因素 客户真正愿意花钱买的是什么？ 利润中最大的一块从哪里获得？ 客户能够轻易地找到并购买更便宜的产品和服务吗？ 关键趋势 技术趋势：识别威胁到你的商业模式的技术趋势，以及能推动你的商业模式进步的技术趋势 你的市场内外的主要技术趋势有哪些？ 哪些技术代表了重要的机会或者颠覆性的威胁？ 哪些新兴技术是边缘客户正在逐步采用的？ 行业管理趋势：描述影响你的商业模式的管理规定和管理趋势 描述关键社会趋势 文化或社会价值观上的哪些变化会影响你的商业模式？ 哪些趋势会影响购买者的行为？ 社会和文化趋势：识别可能影响你的商业模式的社会趋势 描述关键社会趋势 文化或社会价值观上的哪些变化会影响你的商业模式？ 哪些趋势会影响购买者的行为？ 社会经济趋势：总结和你的商业模式有关的主要社会经济趋势 关键的人口统计学趋势有哪些？ 你的市场中收入和财富的分布有哪些特征？ 描述你所处市场的消费特征（比如住房、医疗、娱乐等） 城镇人口相对于农村人口的比例如何？ 行业影响力 （现有的）竞争对手：识别现有竞争对手和他们的相对优势 谁是我们的竞争对手？ 哪些是我们这个领域的主流玩家？ 他们的竞争优势或劣势是什么？ 描述他们的主要产品和服务 他们聚焦哪些客户群体？ 他们的成本结构如何？ 他们对我们的客户群体、收益来源和利润有多大影响？ 新进入者（挑战者）：识别新的、突然出现的玩家，并且审视他们的商业模式是否与你的不同 谁是你所处市场的新进入者？ 他们之间有什么不同？ 他们有什么竞争优势或劣势？ 他们必须克服哪些障碍？ 他们的价值主张是什么？ 他们聚焦哪些客户群体？ 他们的成本结构是什么样的？ 他们对我们的客户群体、收益来源和利润有多大程度的影响？ 替代产品和服务：描述你的产品和服务潜在的替代品，包括那些处于其他市场和行业的产品与服务 哪些产品和服务能够替代我们的产品和服务？ 它们的成本与我们相差多少？ 客户要切换到这些替代品有多容易？ 这些替代产品起源于何种商业模式传统（例如，高速列车挑战飞机，手机挑战照相机） 供应商和价值链上的其他厂商：描述你的市场价值链中现有的关键玩家，并且找出新兴玩家 谁是你的行业价值链中的关键玩家？ 你的商业模式在多大程度上依赖其他这些玩家？ 有边缘玩家在涌现吗？ 哪个的利润最高？ 利益相关者：识别出哪些人会影响你的组织和商业模式 哪些利益相关者会影响你的商业模式？ 股东的影响力如何？员工呢？政府呢？游说者呢？ 宏观经济影响 全球市场情况：从宏观经济角度总结当前整体情况 经济处于爆发期吗？ 描述总体市场情绪 GDP增长率是多少？ 失业率有多高？ 资本市场：描述与你的资本需求相关的当前资本市场情况 资本市场处于什么状态？ 在你所处的市场中，获得投资有多容易？ 现在就能获得种子资本、创业资本、众筹、市场资本或者贷款吗？ 获取这些投资的成本有多高？ 大宗商品和其他资源：关注你的商业模式所需的资源和当前价格和价格趋势 描述你的业务必备的大宗商品和其他资源的当前市场状态（比如原油价格和劳动力成本） 执行你的商业模式所需的资源（比如吸引主要人才）有多么容易获取？成本如何？价格走向如何？ 经济基础设施：描述你的业务市场的经济基础设施 你所处的市场的（公共）基础设施有多优良？ 你如何评价交通、贸易、学校质量，以及连接供应商和客户的便利度？ 个人和企业的税费有多高？ 对商业组织的公共服务有多好？ 你如何评价这里的生活质量？ SWOT评估优势和劣势（SW） 价值主张评估 成本/收入评估 基础设施评估 客户界面评估 机会（O） 价值主张中的机会（整合、服务化与拓展） 价值主张：产品与服务能否整合，产品能否服务化？价值主张的补充和外延？满足客户的额外需求或其它可做的工作？ 成本/收入中的机会（可重复、交叉销售、开源节流） 收入来源：重复性收入代替一次性收入、寻找额外买单元素与交叉销售的机会、新的收益来源、能否提价 成本结构：成本削减 基础设施中的机会（强化核心、减轻负担、转让闲置） 核心资源：核心资源的降本、外包、强化、转让（降本增效、技术壁垒、技术转让） 关键业务：标准化、IT技术带来的整体效率提升 重要合作：外包与核心业务聚焦、交叉销售与更好的客户连接、价值主张补充 客户界面的机会（增长的市场、客户细分、渠道优化与去中间商，客户关系加强与取舍） 客户细分：找到增长的市场并从中获利、服务新客户群体或更细致的已有客户分类 渠道通路：渠道的效率、效益、整合，补充性的渠道伙伴，去中间商、渠道客户匹配 客户关系：加强与客户的关系并提升客户跟进的效果、定制化或可自动维护、提升切换成本、是否抛弃没有利润的客户以及原因 威胁（T） 对价值主张的威胁（可替代性） 产品是否可替代？ 是否会被更有竞争力的价格或更好的价值取代？ 对成本/收入的威胁（利润的威胁、是否单一、缩水、无法预测、无法支撑） 受威胁的利润？是否是技术原因导致？ 是否过度依赖某一项或多项收益来源？ 未来可能消失（或缩水）的收益来源？ 是否有无法预测的成本？（对宏观经济形势的依赖，供应链的稳定性，负面事件的影响与公关） 哪些成本的增加会快过它们所支撑的收入？ 对基础设施的威胁（供应不足、干扰、合作关系波动） 核心资源：某些资源的供应短缺？资源的质量是否有保证？ 关键业务：哪些关键业务会被打扰 ？我们的活动质量能否保证（产品、渠道）？ 重要合作：可能失去的合作伙伴？是否会跟竞争对手合作？是否过分依赖某些合作伙伴？ 客户界面上的威胁（市场竞争、渠道威胁、客户关系恶化） 客户细分：市场是否很快饱和？市场份额被友商威胁？客户转投的可能性？竞争白热化的速度？ 渠道通路：竞争对手是否威胁渠道？（恶意举报）是否存在渠道与客户不相关的危险？ 客户关系：我们的客户关系有可能恶化吗（产品质量与特性无法支持品牌构建）？","link":"/2021/11/20/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E8%AF%84%E4%BC%B0/"},{"title":"Web3.js入门","text":"Web3.js是一个库，它有很多函数，使用它可以在以太坊生态系统中通过HTTP或IPC与本地或者以太坊远程节点交互，如查看链上信息等 各种高级语言编写的程序可以使用web3 interface来与EVM交互，在此过程中使用是的JSON-RPC（一个无状态且轻量级的远程过程调用（RPC）传送协议，其传递内容透过 JSON 为主） 您可以使用web3.js来读取和写入以太坊区块链，而不是使用 ajax 从 Web 服务器读取和写入数据。 1. 获取区块1234var web3 = new Web3(Web3.givenProvider || &quot;http://localhost:8545&quot;);web3.eth.getBlockNumber() .then(console.log); 2. 获取余额12345var web3 = new Web3(Web3.givenProvider || &quot;http://localhost:8545&quot;);web3.eth.getBalance(&quot;0x6b5aC29F2a2Ca361BE4fed60862C51D2F853842a&quot;).then(res =&gt; { console.log(web3.utils.fromWei(res, &quot;ether&quot;)) }) 3. 交易12345web3.eth.sendTransaction({ from:&quot;0x342361F2a62A5820A396e277481d104C0fc3CC60&quot;, to:&quot;0xeF2233172704bbD3A02D35E9d5620a3053F1E2E2&quot;, value:web3.utils.toWei(&quot;1&quot;,&quot;ether&quot;) })","link":"/2023/04/01/Web3-js%E5%85%A5%E9%97%A8/"},{"title":"Webpack入门","text":"从初学前端开始，webpack一直是一个熟悉又陌生的东西。 尽管我会在大部分项目中使用到，但总是局限于基本使用，对多种多样的配置可以说是完全不了解。再加之各类开发框架对其做出的进一步封装，让我更难去接触到webpack本质性的东西。 直到如今，我对webpack的理解还停留在面试题当中关于loader和plugin的问题，除了知道常用的以外，对其机制和原理几乎一无所知。 在此希望通过这篇文章开始重新学习，从整体到局部，对webpack构建一个入门级的较为完整的理解。 作用webpack的官方网站上的描述如下 本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。 简单来说，webpack就是一个模块打包工具。它能够将不同模块的文件打包到一起，并且保证其相互之间的引用的正确性。这也使得我们能够在书写项目时按照相应的业务或是自己的方式划分模块，方便进行模块化开发，同时保证了项目结构的可读性。 webpack还能够对多种格式的文件做编译处理。webpack 本身只能理解 JavaScript 和 JSON 文件，为了扩展其支持多种类型的文件，同时也是为了方便开发者能够自由使用新的语法和特性进行开发，webpack设计出loader，在需要处理新类型文件时，只需添加对应loader即可，通过loader进行编译处理，转化成webpack能够处理的模块。 webpack仅仅拥有上述能力显然还不够作为工程的首选，同时它还支持对自身能力的扩展。webpack中的plugin使得webpack能够执行更广的任务，例如打包优化，资源管理，注入环境变量等，合理使用plugin能够极大帮助我们提高工程化的能力。 以上三点也就是webpack总体上的作用，webpack的设计理念也围绕着以上三点展开，webpack的工作原理也就是关于如何实现以上功能的。 核心概念entry 入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 也就是说，webpack的构建或首先从入口文件开始，通过入口文件递归解析出所有依赖的模块，构建出整个项目的依赖图。 通过配置entry字段可指定项目的入口文件。 webpack.config.js 123module.exports = { entry: './path/to/my/entry/file.js',}; output output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。 通过配置output字段进行指定 webpack.config.js 123456789const path = require('path');module.exports = { entry: './path/to/my/entry/file.js', output: { path: path.resolve(__dirname, 'dist'), // 导入path模块用于操作文件路径 filename: 'my-first-webpack.bundle.js', // 输出的文件名称 },}; loader webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。 在 webpack 的配置中，loader 有两个属性： test 属性，识别出哪些文件会被转换。 use 属性，定义出在进行转换时，应该使用哪个 loader。 webpack.config.js 12345678910const path = require('path');module.exports = { output: { filename: 'my-first-webpack.bundle.js', }, module: { rules: [{ test: /\\.txt$/, use: 'raw-loader' }], },}; 上述配置意味着告诉编译器，在解析到以 ‘.txt’ 结尾的文件时，需要先调用 ‘raw-loader’ 对其进行转换 plugin loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。 由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入一个 new 实例。 webpack.config.js 1234567891011121314151617181920212223const HtmlWebpackPlugin = require('html-webpack-plugin');const webpack = require('webpack'); // 访问内置的插件const path = require('path');module.exports = { entry: './path/to/my/entry/file.js', output: { filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist'), }, module: { rules: [ { test: /\\.(js|jsx)$/, use: 'babel-loader', }, ], }, plugins: [ new webpack.ProgressPlugin(), new HtmlWebpackPlugin({ template: './src/index.html' }), ],}; mode通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。 123module.exports = { mode: 'production',}; 工作流程 初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数。 开始编译：用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。 确定入口：根据配置中的 entry 找出所有的入口文件。 编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。 输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会。 输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统。 上述webpack的整个工作流程是一个串行的过程，同时在这个过程中需要不断广播事件以供插件进行监听，因此需要实现一套完整的事件流。 webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。 webpack 通过 tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。 –吴浩麟《深入浅出webpack》 基本配置仅讨论常用的配置 context 基础目录，绝对路径，用于从配置中解析入口点(entry point)和 加载器(loader)。 123456const path = require('path');module.exports = { //... context: path.resolve(__dirname, 'app'),}; Webpack 在寻找相对路径的文件时会以 context 为根目录，context 默认为执行启动 Webpack 时所在的当前工作目录 entryentry是配置模块的入口，可抽象成输入，Webpack 执行构建的第一步将从入口开始搜寻及递归解析出所有入口依赖的模块。 entry 配置是必填的，若不填则将导致 Webpack 报错退出 单个入口12345module.exports = { entry: { main: './path/to/my/entry/file.js', },}; 也可简写为 123module.exports = { entry: './path/to/my/entry/file.js',}; 也可传入一个文件路径数组，这表示从多个主入口出发，但最终只输出一个chunk。 例如如下配置则表示将file1.js和file2.js合并打包到bundle.js这一个文件中 123456module.exports = { entry: ['./src/file_1.js', './src/file_2.js'], output: { filename: 'bundle.js', },}; 多个入口如果要配置多个入口，则可以传入一个object类型的值。 语法格式：entry: {[entryChunkName: string]: string|Array&lt;string&gt;} 12345678910module.exports = { entry: { app: './src/app.js', adminApp: './src/adminApp.js', }, output: { path: './output', filename: '[name].js' }}; 简单来说，就是以键值对的形式指定多个入口，其中key的值表示输出的chunk名，即输出中的name字段，value的值就是指定入口的路径 也就是说，entry的类型一共有三种 类型 例子 含义 string './app/entry' 入口模块的文件路径，可以是相对路径。 array ['./app/entry1', './app/entry2'] 入口模块的文件路径，可以是相对路径。 object { a: './app/entry-a', b: ['./app/entry-b1', './app/entry-b2']} 配置多个入口，每个入口生成一个 Chunk outputfilenameoutput属性接收一个对象，并且对象至少需要指定filename，这也是output配置的最低要求 12345module.exports = { output: { filename: 'bundle.js', },}; 但是在有多个 Chunk 要输出时，就需要借助模版和变量了。前面说到 Webpack 会为每个 Chunk取一个名称，可以根据 Chunk 的名称来区分输出的文件名： 1filename: '[name].js' path配置输出文件存放在本地的目录，必须是 string 类型的绝对路径。 123456789101112module.exports = { entry: { app: './src/app.js', search: './src/search.js', }, output: { filename: '[name].js', path: __dirname + '/dist', },};// 写入到硬盘：./dist/app.js, ./dist/search.js modulemodule 属性用于配置如何处理模块。通常用于配置loader。 loaderrules 配置模块的读取和解析规则，通常用来配置 Loader。其类型是一个数组。 12345678module.exports = { module: { rules: [ { test: /\\.css$/, use: 'css-loader' }, { test: /\\.ts$/, use: 'ts-loader' }, ], },}; 上述配置告诉webpack使用css-loader加载css文件，并通过ts-loader将ts文件转换成js。 通常配置一项rules大致过程如下： 条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件。 应用规则：对选中后的文件通过 use 配置项来应用 Loader，可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader，同时还可以分别给 Loader 传入参数。 重置顺序：一组 Loader 的执行顺序默认是==从右到左==执行（即从传入数组的末端开始向前执行），通过 enforce 选项可以让其中一个 Loader 的执行顺序放到最前或者最后。 include include表示需要命中的目录，即只有指定的目录会做处理 1234567include: path.resolve(__dirname, 'src')// 指定多个目录include:[ path.resolve(__dirname, 'src'), path.resolve(__dirname, 'tests'),] exclude include表示排除在外的目录，即指定的目录不会做处理 1234567exculde: path.resolve(__dirname, 'node_modules')// 多个exclude:[ path.resolve(__dirname, 'node_modules'), path.resolve(__dirname, 'bower_modules'),] use use配置项用于指定调用的loader 1use: ['style-loader', 'css-loader', 'sass-loader'], 当loader需要传入参数，可以传入一个object 12345678910111213141516171819module.exports = { module: { rules: [ { test: /\\.css$/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { modules: true, }, }, { loader: 'sass-loader' }, ], }, ], },}; 以下是一个较为完整的例子 123456789101112131415161718192021222324252627module: { rules: [ { // 命中 JavaScript 文件 test: /\\.js$/, // 用 babel-loader 转换 JavaScript 文件 // ?cacheDirectory 表示传给 babel-loader 的参数，用于缓存 babel 编译结果加快重新编译速度 use: ['babel-loader?cacheDirectory'], // 只命中src目录里的js文件，加快 Webpack 搜索速度 include: path.resolve(__dirname, 'src') }, { // 命中 SCSS 文件 test: /\\.scss$/, // 使用一组 Loader 去处理 SCSS 文件。 // 处理顺序为从后到前，即先交给 sass-loader 处理，再把结果交给 css-loader 最后再给 style-loader。 use: ['style-loader', 'css-loader', 'sass-loader'], // 排除 node_modules 目录下的文件 exclude: path.resolve(__dirname, 'node_modules'), }, { // 对非文本文件采用 file-loader 加载 test: /\\.(gif|png|jpe?g|eot|woff|ttf|svg|pdf)$/, use: ['file-loader'], }, ]} pluginPlugin 的配置很简单，plugins 配置项接受一个数组，数组里每一项都是一个要使用的 Plugin 的实例，Plugin 需要的参数通过构造函数传入。 1234plugins: [ new webpack.ProgressPlugin(), new HtmlWebpackPlugin({ template: './src/index.html' }), ], 事实上，webpack的插件是一个具有 apply 方法的 JavaScript 对象。apply 方法会被 webpack compiler 调用，并且在 整个 编译生命周期都可以访问 compiler 对象。 1234567891011const pluginName = 'ConsoleLogOnBuildWebpackPlugin';class ConsoleLogOnBuildWebpackPlugin { apply(compiler) { compiler.hooks.run.tap(pluginName, (compilation) =&gt; { console.log('webpack 构建正在启动！'); }); }}module.exports = ConsoleLogOnBuildWebpackPlugin; 因此在配置时，需要传入一个new实例。","link":"/2023/04/02/%E5%AF%B9Webpack%E7%9A%84%E7%90%86%E8%A7%A3/"},{"title":"结合webpack源码理解核心原理","text":"在入门的文章里，仅对webpack的构建流程做了一个初步的解析，但也仅仅是入门而已。 当前的理解仍停留在会用和会配的阶段，再加之各类脚手架出现让使用变得极其方便。但webpack仍然如同一个黑盒，不深入理解原理也难以解决使用中遇到的诸多问题，更不用提性能优化了。 然而官方文档的描述实在难以把握，只能边学习优质文章的讲解边结合源码进行理解，尽量输出成一篇较为完整的工作流程 核心流程在入门时，大致梳理了webpack的工作流程，实际上可划分为三个阶段。 初始化阶段 构建阶段 生成阶段 初始化阶段初始化参数从配置文件、配置对象以及命令中读取参数 首先会读取用户配置中的参数 在获取到参数后，会对options进行校验 1234567891011// webpack.js// webpack.create()if (!asArray(options).every(webpackOptionsSchemaCheck)) { getValidateSchema()(webpackOptionsSchema, options); util.deprecate( () =&gt; {}, &quot;webpack bug: Pre-compiled schema reports error while real schema is happy. This has performance drawbacks.&quot;, &quot;DEP_WEBPACK_PRE_COMPILED_SCHEMA_INVALID&quot; )();} 创建compiler对象将上述经过校验的用户参数，结合默认配置获得最终的完整参数，创建compiler对象，并加载各类插件 主要逻辑由createCompiler方法负责 首先调用createCompiler方法开始创建compiler 12345// webpack.js// webpack.create()let compiler;compiler = createCompiler(webpackOptions); 合并默认配置 12345// webpack.js// createCompiler()const options = getNormalizedWebpackOptions(rawOptions);applyWebpackOptionsBaseDefaults(options); 创建compiler 1234// webpack.js// createCompiler()const compiler = new Compiler(options.context, options); 加载NodeEnvironmentPlugin插件，该插件主要负责文件I/O还有监听文件内容改变 123456// webpack.js// createCompiler()new NodeEnvironmentPlugin({ infrastructureLogging: options.infrastructureLogging}).apply(compiler); 加载用户定义的插件 123456789101112// webpack.js// createCompiler()if (Array.isArray(options.plugins)) { for (const plugin of options.plugins) { if (typeof plugin === &quot;function&quot;) { plugin.call(compiler, compiler); } else { plugin.apply(compiler); } }} 调用WebpackOptionsApply中的process方法，加载webpack内置的插件，包括处理entry配置的插件EntryOptionPlugin 1234// webpack.js// createCompiler()new WebpackOptionsApply().process(options, compiler); 以下是createCompiler方法的完整代码 123456789101112131415161718192021222324252627/** * @param {WebpackOptions} rawOptions options object * @returns {Compiler} a compiler */const createCompiler = rawOptions =&gt; { const options = getNormalizedWebpackOptions(rawOptions); applyWebpackOptionsBaseDefaults(options); const compiler = new Compiler(options.context, options); new NodeEnvironmentPlugin({ infrastructureLogging: options.infrastructureLogging }).apply(compiler); if (Array.isArray(options.plugins)) { for (const plugin of options.plugins) { if (typeof plugin === &quot;function&quot;) { plugin.call(compiler, compiler); } else { plugin.apply(compiler); } } } applyWebpackOptionsDefaults(options); compiler.hooks.environment.call(); compiler.hooks.afterEnvironment.call(); new WebpackOptionsApply().process(options, compiler); compiler.hooks.initialize.call(); return compiler;}; 开始编译 调用compiler.watch与compiler.run方法 12345678910111213// webpack.jsconst { compiler, watch, watchOptions } = create();if (watch) { compiler.watch(watchOptions, callback);} else { compiler.run((err, stats) =&gt; { compiler.close(err2 =&gt; { callback(err || err2, stats); }); });}return compiler; 在compiler.run方法中会调用compiler.compile开始编译 构建阶段","link":"/2023/04/03/webpack%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"},{"title":"React中的“反直觉”（1）：关于useState","text":"关于React的争论在近日又引发了强烈讨论。有人说，React的新版文档写的很好，对React中易错的误区进行了详尽的阐释。也有人说，React的发展在不断加重开发者的心智负担。作为一个受众如此之广的框架，遇到这些相当“反直觉”的概念误区，没有去想办法做改进，反而让开发者去接受这些“反直觉”的概念，开发者是否对React太过宽容了？ 但不论如何，对于React的开发者来说，这些“反直觉”的概念，为了避免出错，还是应当有一个准确的认知，这也是本人更新这个系列的初衷。 本系列的内容基于React18 那让我们从最常用的概念说起：useState。 setState后发生了什么？state快照React的官方文档将state比喻成一张快照，组件的每次重新渲染，会去使用拿到的最新的state快照，计算它的props、事件处理函数和内部变量，从而去更新UI。 简单来说，当 React 重新渲染一个组件时： React 会再次执行该函数组件 函数会根据当前渲染时的 state 返回新的 JSX 快照 React拿到新的JSX快照去进行DOM更新 在有了这样一个基本认知后，我们再思考一个关于setState很经典的例子： 1234567891011121314export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 1); setNumber(number + 1); setNumber(number + 1); }}&gt;+3&lt;/button&gt; &lt;/&gt; )} 上述例子的结果对于大部分React开发者都是显然的，最终点击按钮后，number只会加1。这是因为setState 只会为下一次渲染变更 state 的值，在onClick触发的那一次渲染中，number的值始终为0，即便在调用了 setNumber(number + 1) 之后，number 的值也仍然是 0，因为此时仍停留在上一次渲染中。 然后我们再思考一个经典问题： setState到底是同步还是异步？先说结论：setState不应该将被理解为js中的异步，但它表现的很像“异步”。例如我们在同一个事件处理函数中，在更新了state后立即去取该state的值，会发现其还是更新前的值。 但下面的例子又能很好地证明setState并非是一个异步任务，最终alert的值还是0： 123456789101112131415export default function Counter() { const [number, setNumber] = useState(0); return ( &lt;&gt; &lt;h1&gt;{number}&lt;/h1&gt; &lt;button onClick={() =&gt; { setNumber(number + 5); setTimeout(() =&gt; { alert(number); }, 3000); }}&gt;+5&lt;/button&gt; &lt;/&gt; )} state会带给我们这种似异步而又非异步的感觉，和React的调度机制密切相关。 在上文中我们已经构建了关于state快照的心智模型。React的调度机制正是以快照为单位 参考 Adding Interactivity - React Managing State","link":"/2024/01/07/%E5%85%B3%E4%BA%8EuseState/"}],"tags":[{"name":"html","slug":"html","link":"/tags/html/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"商务智能","slug":"商务智能","link":"/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"响应式","slug":"响应式","link":"/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"课程","slug":"课程","link":"/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"需求与商业模式","slug":"需求与商业模式","link":"/tags/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Web3","slug":"Web3","link":"/tags/Web3/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"React","slug":"React","link":"/tags/React/"}],"categories":[{"name":"html","slug":"html","link":"/categories/html/"},{"name":"课程笔记","slug":"课程笔记","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","link":"/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"html","slug":"前端/html","link":"/categories/%E5%89%8D%E7%AB%AF/html/"},{"name":"CSS","slug":"前端/CSS","link":"/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"HTML","slug":"前端/HTML","link":"/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"需求与商业模式","slug":"课程笔记/需求与商业模式","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E9%9C%80%E6%B1%82%E4%B8%8E%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"},{"name":"商务智能","slug":"课程笔记/商务智能","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"Web3开发","slug":"Web3开发","link":"/categories/Web3%E5%BC%80%E5%8F%91/"},{"name":"Web3","slug":"Web3","link":"/categories/Web3/"},{"name":"Web3开发","slug":"Web3/Web3开发","link":"/categories/Web3/Web3%E5%BC%80%E5%8F%91/"},{"name":"Webpack","slug":"前端/Webpack","link":"/categories/%E5%89%8D%E7%AB%AF/Webpack/"},{"name":"前端工程化","slug":"前端/前端工程化","link":"/categories/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"React","slug":"前端/React","link":"/categories/%E5%89%8D%E7%AB%AF/React/"}],"pages":[]}