{"pages":[],"posts":[{"title":"HTML5新特性","text":"HTML5 是下⼀代 HTML 标准。HTML , HTML 4.01的上⼀个版本诞⽣于 1999 年。⾃从那以后，Web 世界已经经历了巨变。HTML5 是 W3C 与 WHATWG 合作的结果,WHATWG 指 WebHypertext Application Technology Working Group。HTML5 是专⻔为承载丰富的 web 内容⽽设计的，并且⽆需额外插件。HTML5 拥有新的语义、图形以及多媒体元素。HTML5 提供的新元素和新的 API 简化了 web 应⽤程序的搭建。HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、⼿机、电视机等等）之上运⾏ 新增标签 语义化根据结构化的内容选择合适的标签，&lt;header&gt;，&lt;footer&gt;，&lt;nav&gt;，… 有利于SEO 开发维护体验好 ⽤户体验更好 更好的可访问性，⽅便任何设备对代码进⾏解析 Microdata 与 schema.org 结合搜索引擎，⽹络抓取⼯具和浏览器可以从⽹⻚中提取和处理微数据，并使⽤它为⽤户提供更丰富的浏览体验。⾕歌和其他主要搜索引擎⽀持结构化数据的Schema.org词汇表。⾕歌，微软和雅⻁等主要搜索引擎运营商依靠schema.org 词汇表来改进搜索结果。 增强表单 新增input输入类型，改善更好的输入控制和验证，如 color，date，email，number，tel等 新增表单属性：placehoder，required，pattern，autofocus，autocomplete，min，max等 媒体html5提供了音频和视频文件的标准 音频 12345&lt;audio controls&gt; //controls属性提供添加播放、暂停和音量控件。 &lt;source src=&quot;horse.ogg&quot; type=&quot;audio/ogg&quot;&gt; &lt;source src=&quot;horse.mp3&quot; type=&quot;audio/mpeg&quot;&gt;您的浏览器不支持 audio 元素。 //浏览器不支持时显示文字&lt;/audio&gt; 视频 12345&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt;您的浏览器不支持Video标签。&lt;/video&gt; 图形HTML5提供了原生绘图功能，完全整合于HTML5 documents (DOM的⼀部分)，由CSS提供样式，由 JavaScript来绘制 canvas绘图MDN Canvas文档 SVG 什么是SVG SVG指可伸缩矢量图形 SVG用于定义用于网络的基于矢量的图形 SVG使用XML格式定义图形 SVG图像在放大或改变尺寸的情况下其图形质量不会有损失 SVG是万维网联盟的标准 SVG的优势 SVG图像可通过文本编译器来创建和修改 SVG图像可被搜索、索引、脚本化或压缩 SVG是可伸缩的 SVG图像可在任何的分辨率下被高质量的打印 SVG可在图像质量不下降的情况下被放大 SVG与canvas对比 SVG SVG 是⼀种使⽤ XML 描述 2D 图形的语⾔ SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可⽤的，您可以为某个元素附加 JavaScript 事件处理器 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发⽣变化，那么浏览器能够⾃动重现图形 canvas Canvas 通过 JavaScript 来绘制 2D 图形 Canvas 是逐像素进⾏渲染的 在 canvas 中，⼀旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发⽣变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 存储HTML5 web存储是⼀个⽐cookie更好的本地存储⽅式。 客户端存储数据的两个对象为： localStorage - ⽤于⻓久保存整个⽹站的数据，保存的数据没有过期时间，直到⼿动去除。 sessionStorage - ⽤于临时保存同⼀窗⼝(或标签⻚)的数据，在关闭窗⼝或标签⻚之后将会删除这些数据。 其他API 地理位置 HTML5 Geolocation API ⽤于获得⽤户的地理位置 拖放 在html5中，拖放是标准的一部分，任何元素都能够拖放 1&lt;div draggable=&quot;true&quot;&gt;&lt;/div&gt; 当元素拖动时，我们可以检查其拖动的数据 123456&lt;div draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot;&gt;&lt;/div&gt;&lt;script&gt;function drap(ev){ console.log(ev);}&lt;/script&gt;","link":"/2021/09/12/HTML5/"},{"title":"商务智能复习","text":"概要 前继课程 数据库系统原理 关系数据模型 连接 数据库构建的步骤和方法（概念到逻辑 逻辑到物理） 后继课程 数据挖掘 评分 作业30%-40% 考试60%-70% 商务智能的起源 数据库系统的发展 最主要：关系模型 数据层级和业务逻辑的解耦 一份数据可以为多个应用使用 以关系型数据库为基础 数据存放代价越来越低 导致业务系统和信息系统越来越复杂，累积了大量数据（数据库不值钱辣 数据库越来越多，数据会变得越来越定制化 其他倾向（使得数据越来越多）: 计算平台的发展 计算、存储、网络/非网络（物理介质）传输能力 ==采集手段的发展== 基于光学——二维码、图像、视频 传感器、移动设备 RFID（物联网） 👇 ==数据爆炸== 数据、信息、知识 知识值链：数据 数据的意义或信息是由附加在这个数据上的其它内容来说明的，数据本身并不知情 exp： 5000是什么？ price：5000才可以说明问题 在应用开发的阶段，不需要让用户知道数据的意义，只有DBA和对当前数据库做增删改查的业务系统的开发人需要知道这层意义（当然很多情况下他们就是一类人） 知识值链：信息 一系列有关联的数据组合，互相进行解释，使得它们的歧义变得相对更少，得到信息 知识值链：知识 信息中的数据，为什么是这个值，不是其它的值 企业的新问题 企业决策需要 全面了解企业和行业的真实状况 真实状况来自于真实完整的数据 有效将收集的数据转化为信息并最终为企业决策所使用 零售业的EXP： 在复杂零售集团中，有两套业务系统，分别对于统一的和专有的内容进行管理，比如各个部门有自己的系统，但是集团人员的管理是统一的 但是部门太多，每个部门有自己的information workers，每个部门都是摸象的盲人，企业决策者是听取所有摸了象的盲人的报告的盲人，怎么决策？（不能信任任何一个信息工人 要把企业的所有相关情况按照全局方式进行展现👇 数据爆炸、信息贫乏的情况下，要解决信息的： 可访问性 及时性 表达格式 完整性 早期解决方案 第一代：基于主机的查询与报表 只能把少部分信息按照规定的格式推送给决策者 这些报表是有限的数据片段（构不成完整信息体）的有限的信息，过于琐碎，也不完整 第二代：数据仓库 把有限的数据片段聚合，以信息体作为存放单元 仓库中的数据默认统一、一致、完整、”正确“ 为何需要商务智能 如何访问数据仓库？如何利用信息体？ 用机器来做决策？ 商务智能 商务： Buying and selling; commerce; trade 智能（约等于人工智能）：（不适用于商务）（没有规则、没有评估标准） 人工智能：图灵测试、专家系统（典型：人工医疗系统，把西医的专业知识写成概率数据） 目标： 并非解决商务领域的人工智能 改善信息访问 现状：数据分散，而数据仓库中的数据过于完整繁杂 需要精确而概要的数据 仍旧是以人来进行主导： 精力限制 知识背景限制，数据是用来验证猜测的，但知识背景会限制猜测，所以更高级的目标是决策支持 决策支持 只是提供一种支持，比如发现的规律，并非做决策 自动化、半自动化产生输入，决策仍由人来做 比如面包和牛奶高度相关是一个自动化产生的输入，但超市到底应该怎么摆这两样东西，还是由人来决策（而且决策可能完成不一样） 概念：BI是将数据转换为有意义的内容的过程 BI通过把来自于不同系统的数据汇聚成一个单一的可获取的信息源并放入数据仓库（Data Warehouse） 然后基于用户的要求，使用各种工具来分析数据仓库中的数据，并可视化结果，再交给用户做决策 BI系统的功能 不仅支持最新的IT技术，同时也提供打包的应用解决方案（针对企业的立足领域） 前者是日常操作的解决方案，比较固定，可能定期调用，需要的东西不会产生太大的变化 战术性决策支持——影响程度小、执行周期固定 但有些决策是随时间会发生很大的变化的，需要的数据可能也不一样，这就是后者的作用 战略性决策支持——没有套路、提供工具随用随构建 商务智能的构件商务智能的发展商务智能的构件1. BI的构件 传统数据存储：数据库、文件、主页（main frame）、专业相关业务系统、个人计算机（本地） 存的是数据片段（大象的碎片嘿） 结构由每一个业务系统在开发时要解决的问题决定，而非决策人员或BI系统 大噶都是数据源，广义上来说也在BI系统中，狭义上说这块东西本质不可控，BI系统不含数据源 数据仓库 存放信息体 关系模型、多维数据库 也可以拿出一部分作为数据集市，方便管理、提高效率 从1 ==&gt; 2有一个转换（数据到信息的转换） 数据整合ETL 把数据片段整合成信息体 组合得到的信息不一定是正确的，但认为是完整、统一、正确的 相关分析 可视化、脚本…… 提供战略性决策支持 ===&gt; 狭义认为商务智能系统包括：数据仓库和对其中数据进行分析的工具 2. 数据仓库part integrative data 是冗余的数据 当由操作需要比较大的数据量，并且这个操作不会只进行一次，为了提高效率，需要integrative data 数据库是做不到的 3. 数据获取（从1-2的转换需要） 建模工具 不同地方的数据片段可能会对同一样东西进行不同的编码 映射到数据仓库需要建模工具 元数据 ETL 是元数据和建模工具的编码结果 4. 数据与信息 源数据、转换过程——数据 数据仓库——数据&amp;信息 分析工具——信息 5. 数据源 包含内容 操作型数据库 历史数据 包括： 如果是已经用不到的历史数据，会被放到廉价的非在线的存储设备中 当有重要的历史数据需要被查询时，还是可以找到的 也有本操作型/事务型数据库创建之前的历史数据 外部数据（“外部”由企业边界所决定） 没有太大必要性（有必要的话就在操作型数据库中了） 可能是其它企业的数据、中央政策啥的 对于事务性任务来说并不需要，但对于决策分析来说是有必要的，所以也是BI系统的数据源 数据仓库中的信息 一种理解：对数据仓库中的信息进行了分析之后得出的结论又作为数据源放入数据仓库的各个信息体中，使得它们更完整 另一种理解：理论上来说一个企业应该只有一个数据仓库（数据一致性的问题），而外部数据很有可能是一个外部仓库 相关的数据库和数据结构 ===&gt; 数据源存在于不同平台，可以是格式化的，也可以是非格式化的 6. 数据仓库 是BI的重要组成部分和数据基础 工作： ETL： 数据抽取、转换、装载 辨识和主题相关的原始数据 并不是所有采集到的数据都适合作为信息体的一部分（毕竟我的目的是由企业目标决定的，而不是要搞出一个完整的信息体来） 去除分析型环境下无用的数据（高度主观） 数据是否有用和主管分析、上下文、企业关注点有关 开发正确的数据抽取策略 抽取正确和完整的数据 正确的话，比如理解数据源中的编码方式 要达到完整，数据结构要完整，数据源一定要完整，时间上也要完整 将原始数据转换为目标规格 是多到多的映射关系 数据源多个 数据仓库中会有冗余（可能经过了操作 integrative data） 将原始数据加载到预定目标区域 数据目标 数据管理 存储、索引、备份 不仅管理关系数据库中的数据 而且管理数据立方体中的多维数据 数据访问 面向多种商业用户 需要支持多种访问方式以及分析和展现工具 元数据 关于数据的数据，是管理数据仓库的重要数据 描述数据的结构、内容、编码、索引等 种类 关于数据源的元数据 需要正确解析数据源中的数据 关于数据模型的元数据 关于数据仓库映射的元数据 映射成局部的数据、数据集市、数据的概要等 关于数据仓库使用的元数据 比如数据仓库中已经存了一些中间结果可以直接用 元数据管理 7. 分析和展现层 报表和查询 定制报表和查询的能力 OLAP（联机分析处理） 快速的、交互式的相互融合的信息访问方式 可以回答who、what、how、why类的问题 数据库是单维的（列才有意义） 特点 对数据进行多维审视的能力 相关数据已经被整合到一起了 ===&gt; 信息 精密计算能力 时间智能 基本操作 数据统计 将数据中含有的信息概括为统计值 数据挖掘 对数据库（数据仓库）中蕴涵的、未知的、非平凡的、有潜在应用价值的模式（规则）的提取 蕴涵的：非显式的，但数据会对”挖掘“出的决策产生支持 未知的：只针对当前数据集或以后和该数据集有相同规则的其它数据集 非平凡的：无法判定结果的100%对或100%错 不同的数据方法、同一种数据方法不同的参数、同一种数据方法同一个参数运行多次 都有可能得出不同结论 用于发掘数据中隐藏的模式 可以自动化、可以人工 数据上升到信息 商务智能的解决方案商务智能的发展数据仓库从数据库到数据仓库 数据处理分类 操作型处理（增删改查、“随机”发生） 事务处理 对数据库的日常联机访问操作 通常仅仅对一个或一组记录的查询和修改 AKA：联机事务处理（OLTP） 查询简单，执行频率高 关心的是处理的响应时间、数据的安全性和完整性等 分析型处理 AKA：信息型处理 拿到的东西是既成事实，无法修改 主要用于企业管理人员的决策分析，提供辅助决策信息 主观性强，大部分操作事先是未知的 需要对大量事务型数据进行统计、归纳和分析 需要访问大量的历史数据、内外部数据 执行频率不高，对响应时间的要求不高 所面向数据的分类 操作型数据 事务处理所需要的细节性的数据 分析型数据 从操作型数据中加工整理得到 是分析处理所需要的综合性数据 多维的 是只读的 信息系统的发展历史 事务处理系统（TPS）对数据库进行增删改查 管理信息系统（MIS）基于数据库产生的统计报表 统计报表仅基于当前数据库 不可定制 对一些影响比较小的决策起一些作用 主管信息系统（EIS） 跨若干数据库，做全局意义上的决策 需要外部数据 决策支持系统（DSS） 增加了算法 OLAP / DM 基于数据仓库 决策支持系统 数据（数据库、方法库） 算法与模型 展示 事务处理环境和分析处理 在关系数据库中放宽对冗余的限制 数据库以前不允许冗余，因为会有数据一致性问题（all or nothing） 但问题是，所有分析型数据都是操作型数据的冗余嘿 在事务处理环境下建立传统DSS——不适宜 性能特性不同 事务处理 &lt;—&gt; 分析处理 要同时实现可能会非常麻烦（而且不一定能实现 数据集成的问题 DSS需要集成的数据，可能来自多种不同的数据源 事务处理只需要部分细节数据，是分散的 “蜘蛛网”问题 — 每个数据库的数据来源可能错综复杂（互相抄属性值） 数据不一致问题 分散的概念： 对于数据来说，一个信息体的数据项是分散的 对于信息体来说，信息体本身也是分散的 带来的问题 性能很差，可能集成时需要等待很慢的数据库 数据的动态集成问题 人工方式只能做一次集成 — 静态集成 — 难以实现“周期性刷新”（动态集成） — 传统事务处理环境无法实现 历史数据问题 分析处理更看重历史数据，而事务处理一般只需要当前数据 事务处理环境（数据库）下历史数据未能得到充分利用，会被放在别的地方 历史一致性 / 完整性 当前数据库只保有当前最新状态，并不会体现状态的更新和修改过程（因为并不在乎历史数据），比如limit从2500更新到5000，最后拿到历史数据的时候，limit就是5000，不会存在2500 修改主键 or 增加表 使用连接 数据的综合问题 分析处理需要大量的总结性分析型数据 数据库：“数据丰富、信息贫困” 传统事务处理系统不具备综合能力，甚至这种综合还会被认为时一种数据冗余而被限制 数据的访问问题 分析处理的访问以读为主，不需要实时“更新”，但需要周期“刷新” 综上：出现了数据仓库 并非替代数据库 两者目的不同 ​ 数据仓库及其四大特征 定义 是一个面向主题的、集成的、稳定（非易失）的、随时间不断变化的数据集合 用于支持经营管理过程中的决策制定 面向主题（与数据库区别最大的特征） 数据库：面向应用 与数据流程高度相关 逻辑数据不完全分离 和部门、组织紧密相关 信息体不完全 数据仓库：面向主题 抽象 按照某种方式把原来的数据按定义的上下文整合成信息体中的某一个领域 可能不是完整的信息体，但是有意义的 主观有需求，客观有数据 不同主题有重叠内容，但这种重叠的特点是： 逻辑上的而非物理存储上的 部分细节重叠 可以反映不同主题之间直接和间接的关系 每个主题所需数据的物理存储 多维数据库 多维数组 关系数据库 用二维数据模型来存放多维数据 集成 方法： 统一：消除不同数据源之间数据不一致的现象 综合：综合计算 非易失的（稳定的） 数据仓库的数据与操作性数据环境隔离 但数据仓库中的数据也是需要“更新”的 时变的（随时间不断变化） 数据仓库中的数据带有时间属性，包括历史记录和现在的数据都在 以一定时间段为单位进行统一更新 数据仓库的基本结构数据集市于数据仓库数据仓库的应用数据仓库的基本结构数据仓库的关键技术 ETL过程 把来自各种数据源（异构）的数据整合统一后形成一个面向主题的信息体放入数据结构中 数据 ==&gt; 信息 流程： 数据源是异构的：文件、字节流、网页、桌面数据库文件系统等 要从数据源中抽取数据： 必须理解原先数据源中的数据结构、编码等 也要能够理解某一个数据源中的数据与其它数据源中的数据的关系，比如有无重叠、含义是否相同等 解析、校正： 在数据库中，进入数据库前就有各种方法来确保数据正确，那么为什么数据仓库还要校正？ 数据库的数据的校验不能认作靠谱 增补（根据数据项的重要性来选择方法）: 缺失的数据项：大部分的元组都有这个数据项，小部分没有（如果都没有，说明这个数据项就不该存在） 如果有该数据项的元组足够多，那就把那些数据项缺失的元组排除在分析之外 但可能会造成倾斜的数据结果 最坏情况下，完整记录数量会非常少（每个数据项可能都有元组缺失） 以特定标准给元组分类 对于每个类别，以数据项已知的元组来猜测数据项未知的元组 例如： 以每年在某处的平均消费分类，2万以下、2-5万、5万以上 第三类中家庭收入已知的元组大部分家庭年收入在50万以上 合理猜测这一类中家庭收入未知的元组的家庭年收入也在50万以上 匹配： 此时数据结构已经相同，要将属于同一个信息体的数据片段匹配后合并 数据源 可以是递归的 数据的抽取与刷新 刷新的过程是抽取部分的增量 抽取： 是数据进入仓库的入口 屏蔽了底层数据的结构复杂性和物理位置的复杂性 转换和集成的复杂性 操作型环境到数据仓库环境的数据抽取要实现技术上的变化 尽量避免从在线窗口进行数据抽取 在线窗口的数据可能非持久性数据 在线窗口的数据进入数据库时可能已经做过调整，使用更方便 来自操作型环境中的输入关键字在输出到数据仓库之前需要被重建和转换 非关键字要更新格式 存在多个输入记录时，进行记录合并之前要先进行关键字解析（属于同一个信息体的学号、身份证号等要对应起来才能合并） 产生多个输出结果：并发 原来顺序：多个输入 — 1个信息体 — 多个输出（分析数据） 1个信息体可能是瓶颈 ETL工具 数据目标（有效的数据存放位置） 原子层和集成数据 因为计算资源有限，提前算出一些经常使用的数据 ==&gt; 集成数据 数据集市 某个部门或个人分析应用主题用到的数据的子集 提升在特定领域的分析应用效果 操作数据存储ODS 某些部门或个人战术性决策需要实时或准实时的数据 无法在数据仓库中得到直接支持（数据仓库至少以24小时为周期刷新） 在数据仓库以外，持有与数据仓库相同的结构，也是面向主题的 ODS刷新周期较短，刷新频次远高于当前数据仓库 数据仓库面向全局，包含的主题可能有上千个，刷新成本较高，计算瓶颈在数据库 ODS面向明确的、局部的主题，数据量远小于数据仓库 ODS也可以成为数据仓库的数据源（数据结构一样吼） 缓冲区 数据刷新 在原先数据库中确定哪些元组需要更新 确定方式 时间戳：然而问题是大多数数据库中的数据不含有时间属性 DELTA文件： 不信任数据库，应用对数据库进行增删改查时，自己去记录做的操作 效率比较高，不需要对整个数据库对比扫描 但这样的应用很少，理应是数据库完成的任务 日志文件 由数据库自己生成 建立映像文件 做快照（copy） 数据周期（在数据仓库中）：不低于24小时 数据量不以数据周期定义 有些数据库里的数据可能会被撤销，不需要进入数据仓库 刷新会占用软硬件资源和网络传输资源 数据颠簸性 个人理解：数据库中的数据在固定的一段时间内修改得会比较多，这段时间后数据就基本稳定下来了（这个时间一般为24小时） 数据仓库中的数据以及数据管理 数据： 包括细节性业务数据和分析型数据 管理： 借助数据库技术 具体： 原子层（核心、基础）：最详细、数据量最大、存放最多细节 其它数据结构借助原子层来计算分析数据，目的是加速 特点： 保持历史完整性（即记录有意义的历史数据，意义来自主管需求） 构建是迭代的（非一蹴而就） 数据结构是迭代的 随主观 &amp; 客观变化而修改 即使在数据仓库相对稳定的运作过程中，数据内容也在迭代 数据结构面向企业 可以是集成（非原始数据）的 原本最详细是指与数据源中的数据粒度保持一致 若存储资源不足，并且也没有相应需求，则原子层中就存集成数据（在数据源基础上集成 是静态的 一次ETL完毕到下一次ETL开始，原子层是一个静态的镜像，访问多次都是一样的 即一段时间内是静态的 数据库非静态 粒度 对数据仓库中数据的综合程度的一个度量 影响数据仓库中数据量 影响数据仓库能够回答询问的种类 样本数据库（抽样）： 数据仓库的子集，数据量更小 不能用于一般性的分析目的，只能用于统计分析 粒度可以根据采样率高低来划分 多重粒度 分析应用中主流的查询要求是比较综合的，但也会有很小一部分的查询是很细节的 这个细节查询也需要满足 真实数据仓库中：多重粒度 原子层中按最细粒度给出完整数据 从原子层中计算、聚合数据得到高粒度数据以满足综合查询 不同粒度用不同设备存储 多维度、多层次：数据仓库中 维度是观察数据对象的角度 层次是数据对象的综合程度 一个维度中，例如时间维度可以有天、周、月等 每一个对应维度都可以泳有多个层次 数据仓库的数据组织形式 简单堆积文件 轮转综合文件 针对综合层次 在简单堆积之上继续操作 第一层一次写满之后进行聚合放到第二层 第二层和第三层也是一样 简化直接文件 数据集市与数据仓库1. 建立数据集市的原因 数据仓库是全局的，数据量很大，对于一个部门来说，不需要这么多数据就已经可以做出决策了 数据集市（部门数据仓库）是反映子主题的数据仓库的真子集，与部门的分析领域相关 ==数据结构可以和数据仓库不一样== 然鹅理论上来讲是和数据仓库严格对应的，在ETL时就会被写进去 ===&gt; 提高效率与性能 ===&gt; 提高数据安全性（权限控制） 操作型数据库 vs. 数据集市 业务与分析的区别 没有对应关系 数据集市的数据不一定是来源于本部门 联机分析处理OLAP1. OLAP 从OLTP到OLAP OLTP：联机事务处理 OLAP：联机分析处理 OLAP： 专门的数据综合引擎（OLTP【细节】中没有） 公共应用逻辑：数据散布在不同数据源，针对这些数据进行整合的业务逻辑 在短时间内响应非数据处理专业人员的复杂查询要求 要求在线 ===&gt; 短时间 &amp; 在线是无法在OLTP中实现的 针对特定问题的联机数据访问和分析 对信息的很多种可能的观察形式（多维度多层次）进行存取 OLAP vs. OLTP 2. OLAP的特征及衡量标准 Codd关于OLAP的评价准则 OLAP必须提供多维概念试图 信息体是多维的，上下文不止一个 透明性准则 OLAP在体系结构中的位置对用户是透明的 服务器在哪、计算在哪、数据结构如何等都是对用户透明 OLAP的数据源对用户透明 存取能力准则 底层异质数据存储进行多维展现 OLAP存取应该用统一的相同的界面 稳定的报表功能 数据的维数和综合层次增加时，提供报表能力和响应速度不能有明显的减慢 C/S体系结构 现在不一定了，可以是P2P 维的同等性原则 当前信息体在所有维度上能完成的操作应该是一样的 例如普通三维 + 第四维时间，在x轴上可以向后平移，但在时间轴上不可，就不满足同等性 动态的稀疏矩阵处理准则 为什么会存在稀疏问题？ 同等数据量下维度的增加（维度的增加造成可能的取值空间增大） 多用户支持能力准则 并发访问 分时 问题： OLAP往往不止由数据仓库（不要求在线）支撑，还会有其它的支撑 非受限的跨维操作 比如年月日这种固有的层次关系 直观的数据操作 灵活的报表生成 不受限维度和聚集层次 度量值 分析型处理中，关系和分析的对象 数据是衡量的标准 维 观察度量值的角度 度量值关联到其它数据构成维度 层 反映对度量值的观察深度 粒度 按日、周、月、年，都是不同层次 划分方式 OLAP天然支持 指定 细粒度数据不一定能算出高粒度数据 如周数据可能算不出月数据（周可能跨月） 可以主观指定 时间维、地域维、商品维 层次数量和基数成反比 维成员 维的一个取值 可以是层次，也可以是层次组合 多维数组 维度(n) + 度量值(k)、 为每一个维度指定一个维成员（一个集合）来拿取当前度量值 度量值不会被拿出来直接解释 要给定当前维中的维成员 数据单元（单元格） 存放多维数据确定的度量值 多维数组和联机分析处理 可能性很多，需要提升访问性能 3. OLAP的几个基本概念4. OLAP中的数据构造方式 ROLAP（关系数据库管理系统） 把多维数组用关系型数据库管理 多维查询首先要翻译成数据库语言（SQL），期待得到一个结果集 MOLAP 多维数据库管理系统，基本数据模型就是多维数组 下标访问 多维数据引擎直接访问 ===&gt; 更快 HOLAP（混合） 上两种各有利弊 适合放在R的放R，适合放M的放M 反复应用综合数据放在多维数据库（作为加速机制）中 减小数据量 类比缓存（调度、命中） OLAP需要解决的问题 提高数据访问效率 ETL &amp; 查询 &amp; 更新效率 5. OLAP的基本数据模型 更关注OLAP数据访问的效率 数据存放 结合MOLAP和ROLAP MOLAP MDDB vs. RDBMS MDDB： Data File适合放稠密数据，效率会很高（算偏移，直接查 高层次数据会更稠密 高层次数据增加维度有低层次数据支撑 给某个维度插入维成员麻烦（时间复杂度高） 无论数据有无定义，在多维数据模型中都有这个数据的位置 RDBMS： 二维，有定义才会存在于二维表中 两类数据分成两个表存 存放有定义的度量值的事实表 维度使得作为数据的度量值上升为信息 度量值若为向量，则他包含若干列 维度用外关键字来加以涵盖 存放维属性及其取值的维度表 查询： 以维度表作为入口做二维查询 查询得到每一个维度的结果集 把得到的所有结果集进行自然连接后查询事实表 得到事实表的子集（度量值），进行聚合 ===&gt; 效率低于MDDB，但解决了稀疏矩阵的问题 增加维成员不影响原数据结构 增加维度会导致维度表和事实表属性（外关键字）的增加 ===&gt; 应对变化更灵活 星型模型 多维表结构 事实表 x 1 维表 x n 可以转化为一系列二维表 （纸质） 6. 数据立方体（……） 在数据立方体中找到一个合适的维度（子集）与层次 维度的粒度也可自己决定 对数据立方体进行处理 不进行物化 只保留基子方体，粒度最细，需要其它视图时就实时计算 全物化 后台只有多维模型，单OLAP，全算 混合OLAP，算的结果放在数据库或星型模型中 计算、存放资源浪费 部分物化 冰山方体 挑选依据： 整个数据立方体中进行物化需要的资源是多少 不怎么占用资源，实时在线算也可，就不一定需要物化 物化带来的效果 物化也可以有层级 0-D可以基于2-D而不一定基于4-D（方体格中） 7. 多维数据分析 定义：对以多维形式组织起来的数据进行一系列操作后分析 操作： 切片 切掉不关心的数据 切块 旋转 上钻 关注对象仍是本人，但层次上升 细节信息被抹去，信息被概括 视图–&gt;另一个视图 子方—&gt;另一个子方 3D — 2D是一种上钻（某个维度被上升为All 下钻 特例：引入全新维度 维度从ALL下降到具体 ===&gt; 上钻下钻最消耗资源（要考虑支撑信息能否支持实时在线性 ===&gt; 上钻下钻可以实现是因为方体格中有详细信息 drill across 上面讨论的都是单一的数据类型，但维度可以连接事实表，有几个事实表可能就有几个数据立方体 联合分析多个多维模型中的多个度量值 drill through 基本子方不会放在OLAP服务器上 代价高（数据仓库原子层中就有）、没必要 要用到OLAP服务器上没有的详细数据了呢？drill through 数据仓库的设计1. 由来 vs. 数据库 有一致 有不一致 最大的差异在于构思（概念模型设计） 数据库中：数据流分析 数据仓库中：无数据流分析，按某种主题构思星型模型或雪花模型 数据仓库没有需求驱动 它要支撑所有的分析应用，可能部分分析应用的需求是明确的，但没有评价标准 建造数据仓库的主要两部分 与操作型系统接口（ETL）的设计 数据仓库本身的设计 2. SDLC vs. CLDS SDLC: 需求和数据库中的数据是对应的（需求驱动 数据库被交给应用编程人员时，数据库就算是交付完毕（有错再说 此时数据库为空 数据库优先于应用编程存在 CLDS： 有一些客观存在的数据源，但是没有需求 数据源限定了数据项，可以猜测有什么样的需要 数据仓库被构造出来的标志： 完成第一次ETL，仓库中有数据了 DSS应用编程 可能基于猜测的需求和分析人员的明确/不明确的需求 系统测试： 是否缺失需要的数据 结果是否满意 接下来就可以重新理解需求了 ==需求在后== 3. 设计原则 面向主题 vs. 数据库 建立目的 需要执行的分析操作 数据驱动原则 预先定义数据模型 可以和具体实现毫无关联 原型法设计原则 4. 过程/数据模型与设计环境 基于过程的模型 操作型环境 数据仓库中没有过程 数据模型 操作型、分析型环境都可 企业级数据模型 数据模型的性质 稳定性：较少变更的数据放在快速设备上？经常更改的放在慢速上？？？ 会影响到刷新频率 数据模型与迭代开发 迭代开发 新的数据源（客观变化） 数据模型指示迭代方向 预测数据仓库的主题，将主题划分来决定迭代 设计主题的边界（公共维度 ===&gt; 雪花到星座、雪花到雪暴） 不存在没有关联（通过公共维度能够访问到两个主题）的主题 如果迭代1 2 开发的主题1 2 发现没有关联，可以把迭代9的内容提前，因为主题9连接起了1和2 如果没有上述的调整（监管机构和方式方法），瞎比比挑一个顺序开发，会导致 有重叠（浪费） 不一致和冲突 ===&gt; 另一个数据源 再添加主题时，无法将其设计得与现有的乱糟糟的数据模型兼容 不考虑： 各次迭代的开发团队 团队是否并行 数据仓库设计的三级数据模型 概念模型 //高级模型 E-R 逻辑模型 //中极模型 关系模型（数据库中的二维表） 物理模型 //低级模型 逻辑模型在数据仓库中的实现 数据仓库的设计步骤 系统规划： 明确主题 迭代过程所需要的数据模型 从无到有： 这些主题可能只有一个名称（不需要明确细节 主题可能会交给分析人员，由其增删改，最后汇集到数据仓库的设计人员 设计人员提出公共维度 主题 + 公共维度 ===&gt; 数据模型的最小集合 必须要回答的问题（原型设计法）： 有哪些主题 接口是什么 技术准备 具体的技术要求和物理实现环境 迭代“明确主题”part 数据仓库的设计 生成和运维 概念模型设计 一个分析域中的主题放在一次迭代中 概念模型设计 确定系统边界 确定主要的主题及内容 星型、雪花（广义上来说仍然是E-R OLAP等分析应用的设计 逻辑模型设计 将E-R图转成关系数据库的二维数据表 定义数据源和数据抽取规则 数据库中没有 考虑一些问题 粒度划分 详细数据 || 轻度总结 || 高度总结 没有非常明确的、排他的定义，没有定量差异 不同粒度的表是不兼容的 面向的是事实表 数据分割策略 类似于数据库中的分片 分割谁？按什么分割？ 分割事实表 通常采用时间属性作为数据分割的依据 时间几乎是所有事实表都会有的一个外键 可以预估一张子表的规模、大小 定义数据来源及抽取规则 物理模型设计 优化 合并表 减少表的连接（消耗很大）次数 代价：浪费空间 数据库中要么只有分开的表，要么只有合并表（不允许冗余 数据库中所有表的大小是“一样的” / “等价的” 数据仓库中的访问模式并不固定，合并表可能只能满足一小部分的访问 数据仓库中有两种表：维表、事实表（事实表肯定大于维表 数据序列 还是固定访问某些表，但是并不需要所有的属性，可能只是固定的几张表里固定的几个属性 合并表开销太大而且并没有提高性能 把这些固定的属性挑出来放进一个数据结构中（并不合乎逻辑 但注意数据库不能有冗余吼 引入冗余（狭义上的） 表的物理分割（区分于逻辑模型设计中的分割（切元组、切事实表 纵切：对于一张表格中包含的属性进行切分 访问频率 更新频率 决定资源分配：给经常访问但不常更改的快速访问设备，给不常访问常常更新的数据较慢的设备 拆维表，不拆事实表 ===&gt; 从企业级的数据模型中来，或者从log中分析 生成导出数据 给一个没提到的数据物化以后存放的位置？？ 建立广义索引 记录数据仓库中与“最”有关的数据 数据库中不存在（这是个冗余数据 顶不住啊，索引次数太多辽 在每次ETL时进行刷新 如果不需要实时刷新 小程序 需要实时刷新 限制广义索引的范围 业务领域、管理活动中都有 数据仓库生成 建立数据模式 编制数据抽取程序（ETL） 数据加载 数据仓库的使用与维护 6. 数据仓库的生命周期 数据模型分析 粒度分析 逻辑模型分析 数据量的预估 本来在第二个模型才要考虑的，被提前 技术评估 技术环境准备 主题域分析 数据仓库设计 源系统分析 程序说明 编程 ===&gt; 8 9 == ETL 组织构建与主题的明确多维建模1. 多维建模初步 事实表 维度建模的核心 一个事实表对应一个或一组度量值 表中一行对应一个度量值 每一行的粒度应该相同 粒度划分模型 事实表中的度量值 基数很大 基数往往和提供的信息量大小成正比 非文本、枚举、bool等 最常用：数值类型 可以连续取值 三种类型的度量值 可加 可沿某些维度加 不可加（一般不会出现这样的度量值 事实表中的关键字 事实表中有上下文 不同于数据库，数据库的上下文是由应用来定义的而不是由表的内容来定义的 数据仓库中，是通过维度表中的维成员连接事实表，拿取度量值进行聚集得到结果，所以没有必要按照独立的关键字对当前事实表进行检索 每张事实表有&gt;=2个外关键字，用于连接到维表 所有外关键字组合构成主关键字 维度表 事实表的入口，是提供给用户的数据仓库的接口 列用于区分维成员 越多的属性（列）可以越精确地区分维成员 因此维度表的定义通常包括尽可能多的列 维度属性 通常是文本数据或离散数据 使用区间 少使用编码属性（直接用文本描述 数据库中常用编码加速 数据仓库不需要快 问题：当前分析人员能否正确还原编码？（歧义 面向的人员不同（数据库的使用人员是程序员嘿 vs. 度量值属性 事实与维度的融合 2. 多维建模案例 维度建模的设计过程 选取要建模的（分析型）业务处理过程 从零开始：大部分的“需要”是“猜测” 迭代过程：斟酌之前的“需要” 选择事实表中的维度 事实表中的维度表 事实表专有维表，是当前事实表的特定维度，不与其它事实表有关联 公共维表，在多个事实表中进行共享（在进行维度建模前就已经建立（总线（不隶属于维度建模过程，只需要决定要引入哪些 与私有维度无关 2.1 零售营销 需求分析 数据驱动 面向主题 主题不需要很详细，后续会细化修改 维度建模的设计过程 选定维度 日期、商场、产品是从总线中挑选出来的 促销维度是新建的 确定事实 度量值 直接度量值：可以直接从数据源中拿到或通过计算得出 导出型度量值（如毛利润金额 来源于其它度量值，可以放在事实表中，也可以不放，需要用到时现场计算 看存储开销 vs. 计算时间（多长时间被访问一次） 如果不具备可加性，就不需要放置在事实表中 维度设计 前面就应该做好 多级体系划分属性，多对一对应关系，数据量越来越小 分析的角度是组合维度而并非互斥（独立维度） 如果真的是互斥角度，则放在一个维表里会造成空间浪费和分析困难，应该独立出每个维度来，但是没有了组合的概念 会给事实表引入更多的外键（事实表的元组肥肠多，相比之下多出来的空间比我之前放在一起浪费的维度多多了×） 数据仓库中维度不能为null为空 null || 空无法进行连接 使用特殊行来表示null ===&gt; 准确的外关键字 所有用这个特殊外关键字来连接到事实表的都认为该维度为空 存在问题：只存放关心的东西 事实表中只有进行促销并且卖出去的商品，那进行促销但没卖出去的呢？（即本事实表关心的是卖出去的促销商品，以此分析促销对于商品销售的影响 在数据库中没有问题，因为这个说明数据库就是用来记录卖出去的促销商品的 但数据仓库应该支持各种各样的分析需求 需要一个非事实型事实表——促销记录 没有分析价值——没有度量值 需要其它事实表联合分析 为什么不直接放进事实表？ 粒度不同 非事实型事实表中：只要有一个促销组合（组合是上面的概念），就会加入 退化维度 库存事务 库存快照无法提供的分析（为什么需要库存事务）： 无法区分一天之内入库又出库的情况和一直没有入库的情况 无法知道入库的具体情况 分多少次入库 何时入库 ===&gt; 可能会导致运输成本的变动，这是需要分析的点 ===&gt; 当前周期快照粒度过大，无法进行细节性分析 ===&gt; 需要事务性粒度的数据 库存事务类型维度 库存事务的私有维度 库存事务类型组： 按各种标准拆分事务 但数据粒度过细，数据量会增大，要回答一些简单的分析问题时不如库存快照 库存快照和库存事务结合使用（如果两种分析都需要） 库存累积快照 入口事件发生就增加一个元组，所有度量值设为不可用 一个元组中并非所有事件都会发生，如果记录终止在了某个事件上，那么这个事件之后的事件都是“永不发生” 改善库存事务查询普通分析的要求数据时效率过低问题（表的连接过多） 有效加速对于重要采购记录的访问速率 需要的存储空间很大 但进入这个累积快照的数据是有门槛的（重要数据）（大白菜咋了大白菜不好吃啊） 何时认为快照已经被完全构造出来了？ 没有任何一个FK指向“尚未发生” 所有日期类型的FK指向固定日期或“永不发生” 主题的集成 主体之间的维度共享 连线关系为引用关系 ===&gt; 总线结构 数据仓库的总线 总线结构独立于多维建模，事先就被创建好 数据仓库总线矩阵 行：若干个主题或主题细分 列：公共维度 可以确定维度和哪些主题相关，设计该维度时就可以更全面，而不是多次迭代修改数据结构 尽管主题的详细信息都还未知 主题分多次迭代 相关的主题放在一次迭代中 ===&gt; 重叠的公共维度较多 可以根据一次迭代中的主题来决定哪些维度先设计","link":"/2021/12/21/BI/"},{"title":"BFC","text":"定义BFC(Block formatting context) 直译为”块级格式化上下⽂”。它是⼀个独⽴的渲染区域，只有Block\u0002 level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相⼲。 可以理解为 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 Formatting Context Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 形成满⾜以下任意⼀个条件可以创建⼀个新的BFC： 根元素 脱离普通⽂档流的元素（浮动、绝对定位、固定定位），position的值不是static或者relative ⾮块级元素（display属性值是inline-block、table、flex） overflow属性值不为visible的块级元素 布局规则 内部的Box会在垂直⽅向，⼀个接⼀个地放置 Box垂直⽅向的距离由margin决定，属于同⼀个BFC的两个相邻Box的margin会发⽣重叠 每个盒⼦（块盒与⾏盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 BFC的区域不会与float box重叠 BFC就是⻚⾯上的⼀个隔离的独⽴容器，容器⾥⾯的⼦元素不会影响到外⾯的元素。反之也如此 计算BFC的⾼度时，浮动元素也参与计算 作用清除浮动如果父元素没有设置高度，其子元素均为浮动元素，此时父元素会发生高度坍塌 计算BFC的高度时，浮动元素也参与计算 因此使父元素形成BFC即可清除浮动，css3新增属性可以直接触发BFC 1display: flow-root 解决浮动元素覆盖问题兄弟元素设置浮动会产生覆盖问题 BFC的区域不会与float box重叠 使蓝色块触发BFC，即可解决覆盖问题","link":"/2021/09/23/BFC/"}],"tags":[{"name":"html","slug":"html","link":"/tags/html/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"商务智能","slug":"商务智能","link":"/tags/%E5%95%86%E5%8A%A1%E6%99%BA%E8%83%BD/"},{"name":"css","slug":"css","link":"/tags/css/"}],"categories":[{"name":"课程笔记","slug":"课程笔记","link":"/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","link":"/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"html","slug":"前端/html","link":"/categories/%E5%89%8D%E7%AB%AF/html/"}]}